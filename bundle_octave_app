#!/usr/bin/env bash

# bundle_octave_app - Create an Octave.app app bundle
#
# Warning: This program will delete all your existing Homebrew build logs from
# ~/Library/Logs/Homebrew. This is so it can differentiate logs for the formulae
# built for Octave.app from those for any main system-level Homebrew installation.
#
# This script uses sudo when creating the disk image (DMG), and you will need to
# enter your password interactively at that point.
#
# Hints:
#
# If you want to do your compilations single-threaded, which will be slower
# but produce more readable output, set the environment variable
# HOMEBREW_MAKE_JOBS=1 before running bundle_octave_app.
#
# If you're working on getting a release out, consider calling this through one
# of the wip_bundle_* wrapper scripts, for convenience and consistency.
#
# Environment variables:
#
# OCTAPP_CREATEDMG_HOME - Path to the create-dmg repo or installation, if it's not
#   at the default ~/repos/create-dmg location.
# TRACE â€“ Set this to 1 to enable low-level debug tracing of the code in this script.

# Code notes:
#
# This must run under Bash 3.x; can't use Bash 4+ stuff like associative arrays.
#
# Path globals:
#
# * $INSTALL_DIR - The .app dir/bundle under /Applications, which is both its initial
#     build and final installation location.
# * $INSTALL_USR - The Contents/Resources/usr dir under the app at $INSTALL_DIR. This
#     is where most of the brew-managed packages live.
# * $APP_BUILD - The copy of the .app under ./build, where we munge it in to its final
#     form, and create the distribution DMG from.
# * $APP_BUILD_USR - The usr dir under the app at $APP_BUILD, analagous to $INSTALL_USR.
#
# Names and label globals:
# TODO: Fill this out. Maybe move it to a separate .md doc file.
#
# * $APP_NAME -
# * $OCTAVE_FORMULA_VERSION - The version of the octave brew formula used, which may have
#     a "_<revision>" suffix.
# * $OCTAVE_VERSION - The version of Octave, without any revision suffix (e.g. "_1") like
#     in the formula version. Uses all 3 "x.y.z" parts.
# * $OCTAVE_VERSION_LABEL - "Label" form of the Octave version, which uses just "x.y" and
#     omits the final ".z" patch version for ".0" patch releases. This is the "friendly"
#     human-presentable version, and is used in the app name and path.
#
# TODO: "$INSTALL_DIR" is a lousy name for this. Come up with something better.

# TODO: Fix this "python not found" error at the end of the build. Might be as simple as
# using 'python3' instead, since that exists on macOS 12 and 14.
#
# For pkg-config to find octave-octapp@8.3.0 you may need to set:
#   export PKG_CONFIG_PATH="/Applications/Octave-8.3.0.app/Contents/Resources/usr/opt/octave-octapp@8.3.0/lib/pkgconfig"
#
# Uninstalling /Applications/Octave-8.3.0.app/Contents/Resources/usr/Cellar/rust/1.72.1... (38,925 files, 853.2MB)
# Munging app build at ./build/Octave-8.3.0.app
# Octave versions: ver='8.3.0' ver_string='GNU Octave, version 8.3.0' copy='1993-2023 The Octave Project Developers.'
# ./bundle_octave_app: line 695: /usr/bin/python: No such file or directory
#
# TODO: version style controls for app name
#   # valid: 'major', 'minor', 'patch', 'full', or 'none'
#   appname_ver_style='minor'
# TODO: Also, spaces in app name instead of dashes?

set -o errexit
set -o nounset
set -o pipefail
if [[ "${TRACE-0}" == "1" ]]; then set -o xtrace; fi

# Function definitions
#
# (Scroll down to the very bottom to see the main script logic.)

# Utility functions and boilerplate

# A hacky version of realpath, because macOS didn't ship realpath until macOS 13, and we
# still want to run on older versions.
#
# This is the best/most suitable solution of all the stuff I found on SO here:
#   https://stackoverflow.com/questions/3572030/bash-script-absolute-path-with-os-x

function oa_realpath() {
  local file="$1"
  python3 -c 'import os, sys; print(os.path.realpath(sys.argv[1]))' "$file"
}

THIS_PROGRAM=$(basename $0)
THIS_DIR=$(oa_realpath $(dirname $0))

function info()  { echo "$*"; }
function error() { echo >&2 "${THIS_PROGRAM}: ERROR: $*"; }
function die()   { error "$*"; exit 1; }
function verbose() { if [[ $VERBOSE == 'y' ]]; then echo "$*"; fi; }
function is_dry_run() { if [[ $DRY_RUN == 'y' ]]; then return 0; else return 1; fi; }
function wet() {
  if is_dry_run; then
    info "dry run: would run: $*"
  else
    verbose "running: $*"
    "$@"
    return $?
  fi
}
function tic()     { date +%s; }
function toc()     { local t0="$1" t1; t1=$(tic); echo $((t1 - t0)); }
function s2mmss()  { printf "%02d:%02d" "$(($1/60))" "$(($1%60))"; }
function say_toc() {
  local label="$1" t0="$2"
  te=$(toc "$t0")
  info $(printf "Elapsed time: %s: %s" "$label" $(s2mmss "$te"))
}
function timeit() {
  local label="${1:-action}"; shift
  if [[ $# == 0 ]]; then
    die "BUG: timeit() called with too few arguments"
  fi
  t0=$(tic)
  "$@"
  say_toc "$label" "$t0"
}

# Special functions to turn errexit on/off, to support the special no-errexit debugging
# control.

function disable_errexit() {
  set +o errexit
}

function enable_errexit() {
  if [[ $EXIT_ON_ERROR == 'n' ]]; then
    # Leave it disabled bc a debugging option asked for that.
    # In fact, explicitly disable it, because it starts off enabled due to the
    # code-safety settings at the very top of this script; this will get it right at the
    # start of main()
    set +o errexit
  else
    set -o errexit
  fi
}

# Octapp-specific functions

function is_do_sudo() {
  if [[ $USE_SUDO == 'y' ]]; then
    return 0;
  else
    return 1;
  fi;
}

function detect_tool_dependencies() {
  # Check that dependencies of this tool (not of Octave.app) are available. We use
  # system-installed ones instead of installing them in to Octave.app to avoid bloating
  # the app build, and because some are needed before the app is built at all.
  #
  # Sets: CREATEDMG_HOME
  if ! which gsed >/dev/null; then
    die "Could not find gsed. ${THIS_PROGRAM} requires gsed, not just regular macOS (BSD) sed."
  fi
  if ! which python3 >/dev/null; then
    die "Could not find python3. ${THIS_PROGRAM} requires Python 3.x, and the command must be 'python3' and not plain 'python'."
  fi
  if [[ -n "${OCTAPP_CREATEDMG_HOME:-}" ]]; then
    CREATEDMG_HOME="$OCTAPP_CREATEDMG_HOME"
  else
    CREATEDMG_HOME="$HOME/repos/create-dmg"
  fi
  if [[ ! -f "${CREATEDMG_HOME}/create-dmg" ]]; then
    die "No create-dmg found at ${CREATEDMG_HOME}.
Please clone or install the create-dmg repo there, or set the OCTAPP_CREATEDMG_HOME
environment variable to point to your create-dmg repo or installation.

This needs to be the current create-dmg/create-dmg or apjanke/create-dmg repo, not the old
octave-app/create-dmg repo.
"
  fi
}

function usage() {
  cat <<EOHELP

  ${THIS_PROGRAM}
  ${THIS_PROGRAM} [OPTION [ARG]] ...
  ${THIS_PROGRAM} brew <brew_args...>

  Build and package an Octave.app application bundle for macOS.

  The '${THIS_PROGRAM} brew ...' calling form runs an arbitrary 'brew' command in the
  Homebrew installation inside the staged app bundle.

  All other calling forms do regular build operations.

  Several options are supported:

  Packaging options:
    --pre-release <name>
      Declare this to be a prerelease of a given name, using that as the build suffix.
      E.g., 'alpha1' or 'beta1'.
    --update-release <name>
      Declare this to be an update of a given name, using that as the build suffix.
      E.g., 'u1' or 'u2'.
    -u, --build-suffix <suffix>
      Set a build version suffix. Used to distinguish revisions and updates
      to Octave.app's packaging, like 'u1' or 'u2'. This can be used for beta builds, too,
      like '-u beta1'. This is an old option, and the newer --pre-release or
      --update-release option should generally be used instead. [$BUILD_SUFFIX]
    --sign
      Code-sign the completed app bundle. (Probably not working.)

  Octave build options:
    -a, --variant <variant>
      Variant of Octave.app to build. Affects both formula variant and release variant.
    --formula-variant <variant>
      Formula variant to use for the octave formula. [$FORMULA_VARIANT]
    --release-variant <variant>
      Release variant to put in the release and file names. [$RELEASE_VARIANT]
    -V, --octave-version <version>
      Version of Octave formula to build, affecting formula choice.
    -d, --build-devel
      Build the latest Octave development snapshot instead of a released version.
    --tap-branch <branch>
      Use an alternate branch instead of main in the homebrew-octave-app tap.
    -S, --all-from-source
      Build all packages from source instead of using (relocatable) bottles. By default,
      only packages known to have spuriously-relocatable bottles are explicitly built
      from source. But that "known spurious" list may well be incomplete. This option
      guarantees that all packages are built from source.

  Debugging options:
    -h, -?, --help
      Display this help text.
    -s, --step <step>
      Run a single step of the build process (for debugging use).
    -v, --verbose
      Verbose output, and list state of all options.
    -x, --trace
      Trace program execution (even more detail than --verbose). You can also set the
      TRACE=1 environment variable to get the same effect.
    -Y, --dry-run
      Compute values but do not actually build. (Experimental. May fail in various ways.)
    --show-options
      Just show the effective options and resulting choices and exit.
    --debug-no-errexit
      Do not exit on errors. This is a low-level debugging option only for developers.

EOHELP
}

function show_options() {
  local hostname oab_git_sha oab_git_status oab_gitstate_extra oab_ver
  local xcode_version xcode_clt_version clang_version_str latex_version_str
  hostname=$(hostname)
  oab_git_sha=$(git -C "$OCTAPPBUNDLER_HOME" log --pretty=format:'%h' -n 1)
  oab_git_status=$(git -C "$OCTAPPBUNDLER_HOME" status --porcelain)
  if [[ -n "$oab_git_status" ]]; then
    oab_ver="${oab_git_sha}+"
    oab_gitstate_extra=' (with local changes)'
  else
    oab_ver="${oab_git_sha}"
    oab_gitstate_extra=''
  fi
  xcode_version=$(xcodebuild -version | sed -En 's/Xcode[[:space:]]+([0-9.]+)/\1/p')
  clang_version_str=$(clang --version | head -1)
  xcode_clt_version=$(pkgutil --pkg-info=com.apple.pkg.CLTools_Executables | head -2 | tail -1 | sed 's/.* //')
  latex_version_str=$(latex -v | head -1)

  cat <<EOS

${THIS_PROGRAM} run at $(date) on ${hostname}
  macOS ${MACHINE_MACOS_VER}, arch ${MACHINE_ARCH} (${MACHINE_ARCH_DESCR})
  Xcode ${xcode_version}, Xcode CLT ${xcode_clt_version}, clang ${clang_version_str}
  LaTeX: ${latex_version_str}
  ${THIS_PROGRAM} from git commit ${oab_ver}${oab_gitstate_extra}

Options:
formula_variant = ${FORMULA_VARIANT}
release_variant = ${RELEASE_VARIANT}
build_suffix = ${BUILD_SUFFIX} (prerelease = ${PRE_RELEASE}, update_release = ${UPDATE_RELEASE})
octave_formula_version = ${OCTAVE_FORMULA_VERSION}
octapp_tap_branch = ${OCTAPP_TAP_BRANCH}
build_devel = ${DO_BUILD_DEVEL}
build_dmg = ${DO_BUILD_DMG}
use_gcc = ${USE_GCC}
all_from_source = ${BUILD_ALL_FROM_SOURCE}

Values:
octapp_release = ${OCTAPP_RELEASE}
app_name = ${APP_NAME}
octave_version = ${OCTAVE_VERSION}
version_name = ${VERSION_NAME}
octave_version_label = ${OCTAVE_VERSION_LABEL}
octapp_version_label = ${OCTAPP_VERSION_LABEL}
dist_archive_name = ${DIST_ARCHIVE_NAME}
dmg_file = ${DMG_FILE}
dmg_volume_name = ${DMG_VOLUME_NAME}
octave_formula = ${OCTAVE_FORMULA}

Paths:
octappbundler_home = ${OCTAPPBUNDLER_HOME}
createdmg_home = ${CREATEDMG_HOME}
build_dir = ${BUILD_DIR}
build_log_dir = ${BUILD_LOG_DIR}
app_build = ${APP_BUILD}

EOS

}

# The OCTAVE_VERSION is a version number of a main Octave release, in "x.y.z" form. The
# OCTAVE_FORMULA_VERSION is an Octave.app-specific thing which may include suffixes like "_u1"
# to indicate different Octave.app builds or definitions that use the same Octave release.
#
# Pre:  Needs OCTAVE_FORMULA_BASE, DEFAULT_OCTAVE_FORMULA_VERSION,VARIANT
# Post: Sets OCTAVE_FORMULA_VERSION
function pick_default_octave_version() {
  # Bash 3 does not have associative arrays, so we need to do the version lookup with a
  # function. (MacOS is stuck on Bash 3.x for GPL licensing reasons.)
  if [[ "$OCTAVE_FORMULA_BASE" == "octave-octapp" ]]; then
    OCTAVE_FORMULA_VERSION="$DEFAULT_OCTAVE_FORMULA_VERSION"
  elif [[ "$OCTAVE_FORMULA_BASE" == "octave-unversioned" ]]; then
    OCTAVE_FORMULA_VERSION=""
  else
    die "Formula variant '${FORMULA_VARIANT}' (formula base ${OCTAVE_FORMULA_BASE}) has no default version defined. You must supply one."
  fi
}

# Picks names, populating various global variables
function pick_names_for_things() {
  local app_base_name app_base_name_base

  if [[ -z "$FORMULA_VARIANT" ]]; then
    OCTAVE_FORMULA_BASE="octave-octapp"
  else
    OCTAVE_FORMULA_BASE="octave-${FORMULA_VARIANT}"
  fi
  if [[ -z "$RELEASE_VARIANT" ]]; then
    app_base_name_base="octave"
  else
    app_base_name_base="${OCTAVE_FORMULA_BASE}"
  fi
  app_base_name="$(tr '[:lower:]' '[:upper:]' <<< ${app_base_name_base:0:1})${app_base_name_base:1}"
  # Pick default version for variant
  if [[ -z "${OCTAVE_FORMULA_VERSION:-}" ]]; then
    pick_default_octave_version
  fi
  OCTAVE_VERSION="${OCTAVE_FORMULA_VERSION//_[[:digit:]]/}"
  OCTAVE_VERSION_LABEL=$(echo "$OCTAVE_VERSION" | sed -e 's/\.0$//')
  if [[ -z "$RELEASE_VARIANT" ]]; then
    VERSION_NAME="${OCTAVE_VERSION_LABEL}"
  else
    VERSION_NAME="${OCTAVE_VERSION_LABEL}-${RELEASE_VARIANT}"
  fi
  if [[ -z "$OCTAVE_FORMULA_VERSION" ]]; then
    OCTAVE_FORMULA="${OCTAVE_FORMULA_BASE}"
  else
    OCTAVE_FORMULA="${OCTAVE_FORMULA_BASE}@${OCTAVE_FORMULA_VERSION}"
  fi
  # OCTAPP_VERSION_LABEL is exactly the <ver> in "Octave-<ver>.app" for the app bundle
  # file name. By comparison, OCTAPP_RELEASE_LABEL *always* includes the build suffix
  # if there is one, and is used for downloads like the DMG; it's the "container" or
  # publishing name. A single version can have multiple releases. And a single release
  # can have multiple builds or artifacts, like the AS an Intel variant build/DMGs.
  if [[ "$DO_BUILD_SUFFIX_IN_APP_NAME" = y ]]; then
    if [[ -z "$BUILD_SUFFIX" ]]; then
      OCTAPP_VERSION_LABEL="${OCTAVE_VERSION_LABEL}"
    else
      OCTAPP_VERSION_LABEL="${OCTAVE_VERSION_LABEL}_${BUILD_SUFFIX}"
    fi
  else
    OCTAPP_VERSION_LABEL="${OCTAVE_VERSION_LABEL}"
  fi
  APP_NAME="${app_base_name}-${OCTAPP_VERSION_LABEL}"
  if [[ -z "$BUILD_SUFFIX" ]]; then
    OCTAPP_RELEASE="${OCTAVE_VERSION_LABEL}"
  else
    OCTAPP_RELEASE="${OCTAVE_VERSION_LABEL}_${BUILD_SUFFIX}"
  fi
  local dist_arch_extra=''
  if [[ $MACHINE_ARCH == 'x86_64' ]]; then
    dist_arch_extra="-Intel"
  fi
  DIST_ARCHIVE_NAME="${app_base_name}-${OCTAPP_RELEASE}${dist_arch_extra}"
  DMG_FILE="${DIST_ARCHIVE_NAME}.dmg"
  DMG_VOLUME_NAME="${app_base_name} ${OCTAPP_RELEASE}"
}

# "Staging the app build" means to get the working build in to the final install location
# at /Applications/Octave-<blah>.app. Might be made fresh, or moved from -BUILT, or
function stage_app_build() {
  info "Staging app build..."
  if [[ -d "$INSTALL_DIR" ]]; then
    # Reuse already-staged app build
    if [[ -f "$INSTALL_DIR/STAGING" ]]; then
      info "Looks like $APP_NAME is already staged at $INSTALL_DIR; re-using in place"
    else
      die "$INSTALL_DIR exists, but is not a staged build. Please move ${INSTALL_DIR} out of the way before running ${THIS_PROGRAM}."
    fi
  elif [[ -d "$INSTALL_BUILT" ]]; then
    # Move existing staged app build back to staging location
    info "Re-staging existing build dir from $INSTALL_BUILT"
    mv "$INSTALL_BUILT" "$INSTALL_DIR"
  else
    # Create new staged app build
    info "Creating new staged app build at $INSTALL_DIR"
    # mkdir -p "$INSTALL_DIR"
    osacompile -o "$INSTALL_DIR" -e " "
    cat <<EOS > "$INSTALL_DIR/STAGING"
This directory is not a real app!

This is a staged in-progress build created by octave-app-bundler, the build tool for Octave.app.
It cannot be used as a regular app.

If you found this at ${INSTALL_DIR}, then there was probably a failed or incomplete build, and this
directory needs to be manually deleted or moved aside to clean things up.

For more info about Octave.app and octave-app-bundler, see:
  https://github.com/octave-app/octave-app-bundler

EOS
  fi
}

function require_staged_app_build() {
  local err_msg
  if [[ ! -f "${INSTALL_DIR}/STAGING" ]]; then
    err_msg="This step requires a staged app build, but there is no app build staged at ${INSTALL_DIR}."
    if [[ -n "$BUILD_STEP" ]]; then
      err_msg="${err_msg}\nPlease run '${THIS_PROGRAM} -s stage' to stage an app build and then retry."
    fi
    die "$err_msg"
  fi
}

function require_built_app() {
  if [[ ! -d "$INSTALL_BUILT" ]]; then
    die "No built app found at ${INSTALL_BUILT}. You may need to re-run the build."
  fi
}

function freshen_staged_homebrew() {
  local install_type sed

  info "Freshening Homebrew in the staged build..."
  require_staged_app_build
  # Check if we need to do a full install or update existing install
  if [[ -e "${INSTALL_USR}/bin/brew" ]]; then
    install_type='update'
  else
    install_type='full'
  fi

  if [[ "$install_type" == "update" ]]; then
    # Update homebrew
    info "Incrementally building in existing Homebrew installation in ${INSTALL_USR}"
  else
    # Install homebrew
    info "Creating new Homebrew installation in ${INSTALL_USR}"
    mkdir -p "${INSTALL_USR}/bin" "${INSTALL_USR}/var" "${INSTALL_USR}/lib"
    git clone 'https://github.com/Homebrew/brew' "${INSTALL_USR}/Homebrew"
    ln -s "${INSTALL_USR}/Homebrew/bin/brew" "${INSTALL_USR}/bin/brew"
    if [[ -n "$BREW_REMOTE_BRANCH" ]]; then
      (
        info "Checking out Homebrew branch ${BREW_REMOTE_BRANCH} from remote ${BREW_REMOTE_URL}"
        "$brew" update
        cd "${INSTALL_USR}/Homebrew"
        git remote add "$BREW_REMOTE_URL" "$BREW_REMOTE_URL"
        git fetch --all
        git checkout "$BREW_REMOTE_BRANCH"
      )
    fi
    "$brew" tap octave-app/octave-app
  fi

  # Switch to non-default tap branch if requested
  # Looks like brew update resets the branch for taps, so switch it *after* the
  # brew update
  if [[ -n "$OCTAPP_TAP_BRANCH" ]]; then
    (
      info "Checking out octave-app tap branch ${OCTAPP_TAP_BRANCH}"
      # TODO: support new AS dir layout?
      cd "${INSTALL_USR}/Homebrew/Library/Taps/octave-app/homebrew-octave-app"
      git fetch --all
      info "Checking out octapp tap branch in pwd: $(pwd)"
      git checkout "$OCTAPP_TAP_BRANCH"
    )
  fi

  # Force conservative architecture builds in brew's ENV
  # TODO: Can this be replaced with an env var or similar?
  sed='/usr/bin/sed'
  "$sed" -E -i '' "s/ARGV.build_bottle./true/g" "${INSTALL_USR}/Homebrew/Library/Homebrew/extend/ENV/super.rb"
  "$sed" -E -i '' "s/ARGV.build_bottle./true/g" "${INSTALL_USR}/Homebrew/Library/Homebrew/extend/ENV/std.rb"
}

function install_special_build_deps() {
  info "Installing special required build-time packages"
  # svn is needed to fetch the netpbm source
  # TODO: Could this be fixed by adding a build-time dependency on svn to the netpbm formula?
  # TODO: Better yet, can we just require a system-level svn? Doesn't seem to work when done
  # in a separate Homebrew installation (maybe due to brew's environment isolation), so for
  # now, install it in Octave.app and let it bloat up. If we have to do it this way, then we
  # should maybe add subversion and its exclusive deps to the list of packages to prune later.
  # TODO: The HOMEBREW_SVN env var looks like a way to do this.
  if brew deps --include-build "$OCTAVE_FORMULA" | grep netpbm | grep -v netpbm-octapp &>/dev/null; then
    info "This build requires subversion bc it uses regular netpbm. Installing subversion..."
    wet "$brew" install subversion
  else
    info "This build does not require subversion bc it has no dep on regular netpbm. Not installing subversion."
  fi
}

function build_octave_in_staged_app() {
  local build_opts nonreloc_deps brew_install_opts brew_inst_exit brew_inst_octapp_exit

  info "Building Octave.app..."
  require_staged_app_build

  if [[ -e "$INSTALL_BUILT" ]]; then
    die "A built app aleady exists unstaged at $INSTALL_BUILT. Needs manual cleanup."
  fi

  # Fortran: set FC to point to gfortran from the brewed gcc inside the built Octave.app
  export FC="${INSTALL_USR}/bin/gfortran"
  # Scientific libraries may need GCC 6, if using GCC
  # TODO: Is this still needed in 2024? Why exactly did we do it in the first place?
  # TODO: Document exactly which libraries need this.
  if [[ "$USE_GCC" == 'y' ]]; then
    export HOMEBREW_CC=gcc-6
    export HOMEBREW_CXX=g++-6
  fi

  install_special_build_deps

  # Build octave (and its deps)
  build_opts=""
  brew_install_opts=""
  if [[ "$VERBOSE" == "y" ]]; then
    brew_install_opts="$brew_install_opts --verbose"
  fi
  if [[ "$DO_BUILD_DEVEL" == "y" ]]; then
    build_opts="$build_opts --HEAD"
  fi
  # Force building selected dependencies from source
  if [[ $BUILD_ALL_FROM_SOURCE = 'y' ]]; then
    info "Forcing build-from-source of all deps, because --all-from-source was specified"
    local all_deps=$("$brew" deps --include-build "$OCTAVE_FORMULA" | tr '\n' ' ')
    if ! wet "$brew" install $brew_install_opts --build-from-source $all_deps; then
      brew_inst_exit=$?
      die "brew install <all deps> --build-from-source failed: returned failure (exit status ${brew_inst_exit}); aborted."
    fi
  else
    # Force building formulae with non-relocatable bottles, including deps, from source, to
    # avoid picking up bottles that are marked as relocatable but don't actually work in
    # alternate locations, like qt 6
    local dep_temp_file=$(mktemp /tmp/octapp_nr_deps-XXXXXXXXXXXX)
    "$brew" deps --include-build "$OCTAVE_FORMULA" | sort | uniq > "$dep_temp_file"
    nonreloc_deps=$(comm -1 -2 "$dep_temp_file" "${THIS_DIR}/nonreloc_bottles.txt" | tr '\n' ' ')
    rm -rf "$dep_temp_file"
    if [[ -n "$nonreloc_deps" ]]; then
      info "Forcing build-from-source of deps with spurious relocatable bottles: ${nonreloc_deps}"
      if ! wet "$brew" install $brew_install_opts --build-from-source $nonreloc_deps; then
        brew_inst_exit=$?
        die "brew install <non-reloc deps for octapp> failed: returned failure (exit status ${brew_inst_exit}); aborted."
      fi
    else
      info "No deps with spurious relocatable bottles to handle"
    fi
  fi
  if wet "$brew" install $brew_install_opts --build-from-source "$OCTAVE_FORMULA" $build_opts; then
    info "brew install <octapp> returned success exit status"
  else
    brew_inst_octapp_exit=$?
    info "brew install <octapp> exit status: $brew_inst_octapp_exit"
    if [[ $brew_inst_octapp_exit == 1 ]]; then
      if brew_is_installed "$OCTAVE_FORMULA"; then
        info "brew install <octapp> had non-zero exit status ${brew_inst_octapp_exit} but looks successful, because ${OCTAVE_FORMULA} is in 'brew list'. Maybe a keg-only side effect? Treating as successful and proceeding."
      else
        die "brew install <octapp> failed: returned exit status 1, and formula ${OCTAVE_FORMULA} was not installed (not present in 'brew list')"
      fi
    else
      die "brew install <octapp> returned failure, non-1 exit status ($brew_inst_octapp_exit); aborted."
    fi
  fi

  # HACK: remove large build-time-only dependencies to reduce app size.
  # This is done before moving to -BUILT because brew needs to run from
  # the original built location.
  local big_pkg
  info "Removing big build-time-only packages"
  for big_pkg in "${BIG_BUILD_ONLY_PKGS[@]}"; do
    info "Checking for big build-time-only package: $big_pkg"
    if brew_is_installed "$big_pkg"; then
      info "Removing big build-time-only package: $big_pkg"
      wet "$brew" rm "$big_pkg"
    fi
  done

  info "Doing brew cleanup after successful app build"
  wet "$brew" cleanup
}

function brew_is_installed() {
  local formula="$1"
  "$brew" list --formula | grep -x "$formula" &>/dev/null
}

function setup_brew_env() {
  export HOMEBREW_NO_AUTO_UPDATE=1
  export HOMEBREW_NO_ENV_HINTS=1
  #TODO: Use HOMEBREW_SVN to support svn downloads without in-octapp svn install?
}

# Moves the completed build to a -BUILT copy. At that point it's "pristine" and should
# (mostly) no longer be modified. As of 2024-01-18, I think this is redundant with unstage_*.
function move_build_to_stash() {
  if [[ -e "$INSTALL_BUILT" ]]; then
    die "Cannot stash built app. A build aleady exists at $INSTALL_BUILT. Needs manual cleanup."
  fi
  wet mv "$INSTALL_DIR" "$INSTALL_BUILT"
  info "Captured pristine build to ${INSTALL_BUILT} (from $INSTALL_DIR)"
}

# Unstages the completed/staged build to a -BUILD location. As of 2024-01-18, this is
# working exactly like move_build_to_stash, and they can probably be unified.
function unstage_app_build() {
  info "Unstaging app build..."
  if [[ ! -f "${INSTALL_DIR}/STAGING" ]]; then
    die "${INSTALL_DIR} does not look like a staged build from this tool. (Maybe it's a final app from the installer?) Not moving it."
  fi
  if [[ -e "$INSTALL_BUILT" ]]; then
    die "There is already an unstaged app build at ${INSTALL_BUILT}. Cannot un-stage."
  fi
  wet mv "$INSTALL_DIR" "$INSTALL_BUILT"
  info "Unstaged app build to ${INSTALL_BUILT}"
}

# Capture build logs from unstaged app, user Homebrew logs
function capture_build_logs() {
  # Capture the logs
  # This is run after capturing the build to the unstaged location
  local brew_logs_dir octave_test_log
  info "Capturing build logs..."
  wet mkdir -p "$BUILD_LOG_DIR"
  brew_logs_dir="${HOME}/Library/Logs/Homebrew"
  if [[ -d "$brew_logs_dir" ]]; then
    wet cp -pR "$brew_logs_dir" "${BUILD_LOG_DIR}/Homebrew"
  fi
  octave_test_log="${INSTALL_BUILT}/opt/${OCTAVE_FORMULA}/make-check.log"
  if [[ -e "$octave_test_log" ]]; then
    wet cp "$octave_test_log" "$BUILD_LOG_DIR"
  fi
  info "Captured build logs to ${BUILD_LOG_DIR}"
}

# Capture the whole built app from INSTALL_DIR to ./build
function capture_built_octave_app() {
  # Capture the version info from built binaries to a simple file for use later
  # Get versions dynamically from the built program. Stash them in a file inside
  # the app build. That modifies the app build, and is the only modification we do
  # before capturing it for further munging.
  local octave oct_ver oct_ver_string oct_copyright octapp_ver_file formulae_vers_file
  local gs_ver gs_opt gs_share octapp_meta_dir

  # Keep this in sync with the corresponding code below!
  # Just on a hunch that dirs right under the app bundle root interfere with codesigning,
  # moved this under Contents/Resources as of 8.4.0.
  octapp_meta_dir="${INSTALL_DIR}/Contents/Resources/octapp-meta"
  octapp_ver_file="${octapp_meta_dir}/octapp-ver-info.sh"
  formulae_vers_file="${octapp_meta_dir}/octapp-formulae-vers.txt"
  octave="${INSTALL_USR}/opt/${OCTAVE_FORMULA}/bin/octave"
  # x.y.z semver-ish version string
  oct_ver_string=$("$octave" --version | /usr/bin/sed -n 1p)
  oct_ver=$(echo "$oct_ver_string" | /usr/bin/grep -o '\d\..*$' )
  oct_copyright=$("$octave" --version | /usr/bin/sed -n 2p | /usr/bin/cut -c 15- )
  gs_ver=$("${INSTALL_USR}/bin/gs" --version)
  gs_opt=$("$brew" --prefix "ghostscript")
  gs_share="${gs_opt}/share/ghostscript"

  mkdir -p "$octapp_meta_dir"
  cat >"$octapp_ver_file" <<EOS
oct_ver='$oct_ver'
oct_ver_string='$oct_ver_string'
oct_copyright='$oct_copyright'
gs_ver='$gs_ver'
gs_opt='$gs_opt'
gs_share='$gs_share'
EOS
  "$brew" octave-app-list-formulae > "$formulae_vers_file"
  "$brew" list --full-name > "${octapp_meta_dir}/brew-list-fullname.txt"
  "$brew" list --versions > "${octapp_meta_dir}/brew-list-versions.txt"
  "$brew" config > "${octapp_meta_dir}/brew-config.json"
  "$brew" info --installed --json > "${octapp_meta_dir}/brew-info-installed.json"
  info "Saved version info under ${octapp_meta_dir}"
}

function munge_build() {
  local octave oct_ver oct_ver_string oct_copyright
  local octapp_ver_file formulae_vers_file octapp_meta_dir
  local gs_ver gs_opt gs_share
  local keg vers_code oct_mcode oct_site

  info "Munging build..."
  if [[ $DRY_RUN = 'y' ]]; then
    info "dry run: would munge build"
    return
  fi
  require_built_app
  mkdir -p build/logs

  # Make a local copy of the app for munging, clobbering any existing copy
  if [[ -e "$APP_BUILD" ]]; then
    info "Deleting old munged app at ${APP_BUILD}"
    chmod -R u+w "$APP_BUILD"
    rm -rf "$APP_BUILD"
  fi
  info "Grabbing copy of build from ${INSTALL_BUILT} to ${APP_BUILD}"
  mkdir -p "$BUILD_DIR"
  cp -pR "$INSTALL_BUILT" "$APP_BUILD"

  # Get ver info from our custom data file
  # Keep this in sync with the corresponding code above!
  octapp_meta_dir="${APP_BUILD}/Contents/Resources/octapp-meta"
  octapp_usr="${APP_BUILD}/Contents/Resources/usr"
  octapp_ver_file="${octapp_meta_dir}/octapp-ver-info.sh"
  formulae_vers_file="${octapp_meta_dir}/octapp-formulae-vers.txt"
  vers_code=$(cat "${octapp_ver_file}")
  eval "$vers_code"
  info "Octave versions: ver='${oct_ver}' ver_string='${oct_ver_string}' copyright='${oct_copyright}'"

  # Munge it
  info "Munging app in ${APP_BUILD}..."

  # Add a bare "octave" link in the main bin, so when the octapp "env" is loaded,
  # an unqualified "octave" command runs that.
  ( cd "${octapp_usr}/bin"; ln -s "$OCTAVE_FORMULA" octave )

  # Have app use its internal font cache instead of global one
  /usr/bin/sed -i '' 's/\/Applications.*fontconfig/~\/.cache\/fontconfig/g' \
    "${APP_BUILD_USR}/etc/fonts/fonts.conf"

  # App-specific startup configuration
  keg="${APP_BUILD_USR}/Cellar/${OCTAVE_FORMULA}/${OCTAVE_VERSION}"
  oct_mcode="${keg}/share/octave/${OCTAVE_VERSION}/m"
  oct_site="${keg}/share/octave/site"
  cat >>"${keg}/share/octave/site/m/startup/octaverc" <<EOS

% Octave.app special configuration

% Use a distinct version-specific package dir outside of the app bundle.
%
% This avoids changing the app bundle in a way that could break code signing.
% This can also avoid crashes with compiled packages. (Because some compiled
% oct-files have linkage dependency on the exact path to the Octave
% installation, and can't be shared between multiple Octave installations on
% the same machine.)
default_pkg_prefix = pkg ("prefix");
octave_app_pkg_prefix = [getenv("HOME") "/Library/Application Support/Octave.app/${OCTAPP_VERSION_LABEL}/pkg"];
% Create the directory ourselves to avoid a warning in the console
if !isfolder (octave_app_pkg_prefix)
  mkdir (octave_app_pkg_prefix);
endif
pkg ("prefix", octave_app_pkg_prefix, octave_app_pkg_prefix);
pkg ("local_list", [octave_app_pkg_prefix "/octave_packages"]);
clear default_pkg_prefix octave_app_pkg_prefix

% End Octave.app special configuration

EOS

  # Drop a build version indicator
  echo "$OCTAPP_RELEASE" > "${keg}/share/octave/site/Octave.app-RELEASE.txt"

  # Custom octapp functions
  cp -R Mcode/* "${oct_site}/m"
  mkdir -p "${oct_site}/m/+octapp"
  # Expose the original ver.m, which our Mcode masks, as octapp.ver_pristine
  cat "${oct_mcode}/miscellaneous/ver.m" | sed -e 's/function v = ver /function v = ver_pristine/' \
    > "${oct_site}/m/+octapp/ver_pristine.m"

  # AppleScript app launcher script
  local tmp_script=$(mktemp /tmp/octave-XXXX)
    read -r -d '' program_launch_code <<EOS || true
    set cmd to env_setup_cmd() & run_octave_gui()
    do shell script cmd
EOS
  cat <<EOSCRIPT >> "$tmp_script"
  on env_setup_cmd()
    export_lang() & export_gs_options() & export_gnuplot() & export_fc() & export_path() & export_dyld()
  end env_setup_cmd

  on export_lang()
    return "default_lang=\$(osascript -e 'user locale of (get system info)'); export LANG=\$default_lang.UTF-8;"
  end export_lang

  on export_gs_options()
    return "export GS_OPTIONS=\\"-sICCProfilesDir=${gs_share}/${gs_ver}/iccprofiles/ -sGenericResourceDir=${gs_share}/${gs_ver}/Resource/ -sFontResourceDir=${gs_share}/${gs_ver}/Resource/Font\\";"
  end export_gs_options

  on export_gnuplot()
    return "export GNUTERM=\\"qt\\"; export PATH=\\"${INSTALL_USR}/opt/gnuplot-octapp/bin:\$PATH\\";"
  end export_gnuplot

  on export_path()
    return "export PATH=\\"${INSTALL_USR}/bin/:\$PATH\\";"
  end export_path

  on export_dyld()
    return "export DYLD_FALLBACK_LIBRARY_PATH=\\"${INSTALL_USR}/lib:/lib:/usr/lib\\";"
  end export_dyld

  on export_fc()
    return "export FC=\\"${INSTALL_USR}/bin/gfortran\\"; export F77=\\"${INSTALL_USR}/bin/gfortran\\";"
  end export_fc

  on cache_fontconfig()
    set fileTarget to (path to home folder as text) & ".cache:fontconfig"
    try
      fileTarget as alias
    on error
      display dialog "Font cache not found, so first plotting will be slow. Create font cache now?" with icon caution buttons {"Yes", "No"}
      if button returned of result = "Yes" then
        do shell script "${INSTALL_USR}/bin/fc-cache -frv;"
      end if
    end try
  end cache_fontconfig

  on run_octave_gui()
    return "cd ~; clear; ${INSTALL_USR}/opt/${OCTAVE_FORMULA}/bin/octave -q --gui | logger 2>&1;"
  end run_octave_gui

  on run_octave_cli()
    return "cd ~; clear; ${INSTALL_USR}/opt/${OCTAVE_FORMULA}/bin/octave -q; exit;"
  end run_octave_cli

  on run_octave_test_suite()
    return "cd ~; clear; ${INSTALL_USR}/opt/${OCTAVE_FORMULA}/bin/octave --no-window-system --eval '__run_test_suite__' > ~/octave-app-fntest.log 2>&1; exit;"
  end run_octave_test_suite

  on run_octave_open(filename)
    return "cd ~; clear; ${INSTALL_USR}/opt/${OCTAVE_FORMULA}/bin/octave -q --persist --eval \\"edit " & filename & "\\" | logger 2>&1;"
  end run_octave_open

  on path_check()
    if not (POSIX path of (path to me) starts with "${INSTALL_DIR}") then
      display dialog "Please move Octave.app from the ${INSTALL_DIR} folder and run it from there." with icon stop with title "Error" buttons {"OK"}
      error number -128
    end if
  end path_check

  on open argv
    path_check()
    cache_fontconfig()
    set filename to "\\"" & POSIX path of item 1 of argv & "\\""
    set cmd to env_setup_cmd() & run_octave_open(filename)
    do shell script cmd
  end open

  on run argv
    path_check()
    cache_fontconfig()
    if argv contains "--run-test-suite" then
      set cmd to env_setup_cmd() & run_octave_test_suite()
      do shell script cmd
    else
      ${program_launch_code}
    end
  end run

EOSCRIPT

  osacompile -o "${APP_BUILD}/Contents/Resources/Scripts/main.scpt" "$tmp_script"
  cp "$tmp_script" build/logs
  rm "$tmp_script"

  # Create a nice iconset (using the icons shipped with Octave)
  # The following might fail for the development version; TODO: conditionalize or trap the error
  local hicolor_dir svg_icon tmp_iconset
  hicolor_dir="${APP_BUILD_USR}/opt/${OCTAVE_FORMULA}/share/icons/hicolor"
  svg_icon="${hicolor_dir}/scalable/apps/octave.svg"
  tmp_iconset="$(mktemp -d /tmp/iconset-XXXX)/droplet.iconset"
  mkdir -p "$tmp_iconset"
  cp "${hicolor_dir}/16x16/apps/octave.png" "${tmp_iconset}/icon_16x16.png"
  cp "${hicolor_dir}/32x32/apps/octave.png" "${tmp_iconset}/icon_16x16@2x.png"
  cp "${hicolor_dir}/32x32/apps/octave.png" "${tmp_iconset}/icon_32x32.png"
  cp "${hicolor_dir}/64x64/apps/octave.png" "${tmp_iconset}/icon_32x32@2x.png"
  cp "${hicolor_dir}/128x128/apps/octave.png" "${tmp_iconset}/icon_128x128.png"
  cp "${hicolor_dir}/256x256/apps/octave.png" "${tmp_iconset}/icon_128x128@2x.png"
  cp "${hicolor_dir}/256x256/apps/octave.png" "${tmp_iconset}/icon_256x256.png"
  cp "${hicolor_dir}/512x512/apps/octave.png" "${tmp_iconset}/icon_256x256@2x.png"
  cp "${hicolor_dir}/512x512/apps/octave.png" "${tmp_iconset}/icon_512x512.png"
  if [[ -e "${hicolor_dir}/1024x1024/apps/octave.png" ]]; then
    cp "${hicolor_dir}/1024x1024/apps/octave.png" "${tmp_iconset}/icon_512x512@2x.png"
  fi
  iconutil -c icns -o "${APP_BUILD}/Contents/Resources/applet.icns" "${tmp_iconset}"

  # Create or update entries in the application's plist
  local plistbuddy info_plist
  plistbuddy='/usr/libexec/PlistBuddy'
  info_plist="${APP_BUILD}/Contents/Info.plist"
  chmod a+w "${APP_BUILD}/Contents/Info.plist"
  $plistbuddy -c "Add :NSUIElement integer 1" "$info_plist"
  $plistbuddy -c "Add :CFBundleIdentifier string org.octave-app.Octave" "$info_plist"
  $plistbuddy -c "Add :CFBundleShortVersionString string $oct_ver" "$info_plist"
  $plistbuddy -c "Add :CFBundleVersion string \"$oct_ver_string\"" "$info_plist"
  $plistbuddy -c "Add :NSHumanReadableCopyright string \"$oct_copyright\"" "$info_plist"
  $plistbuddy -c "Add :CFBundleDocumentTypes array" "$info_plist"
  $plistbuddy -c "Add :CFBundleDocumentTypes:0 dict" "$info_plist"
  $plistbuddy -c "Add :CFBundleDocumentTypes:0:CFBundleTypeExtensions array" "$info_plist"
  $plistbuddy -c "Add :CFBundleDocumentTypes:0:CFBundleTypeExtensions: string \"m\"" "$info_plist"
  $plistbuddy -c "Add :CFBundleDocumentTypes:0:CFBundleTypeOSTypes array" "$info_plist"
  $plistbuddy -c "Add :CFBundleDocumentTypes:0:CFBundleTypeOSTypes: string \"Mfile\"" "$info_plist"
  $plistbuddy -c "Add :CFBundleDocumentTypes:0:CFBundleTypeRole string \"Editor\"" "$info_plist"
  $plistbuddy -c "Set :LSMinimumSystemVersionByArchitecture:x86_64 \"$MACHINE_MACOS_VER_MAJMIN\"" "$info_plist"
  plutil -convert xml1 "${APP_BUILD}/Contents/Info.plist"
  chmod a=r "${APP_BUILD}/Contents/Info.plist"

  # Add icon to octave-gui (DISABLED)
  # This is broken as of macOS 12, and maybe earlier. It fails with a "ModuleNotFoundError: No module named 'Cocoa'" error.
  # Looks like the Cocoa module doesn't exist in the newer Pythons shipped with macOS. It may have been a Python 2 thing;
  # macOS has switched to Python 3 since the last time this worked.
#   local python_script_tmp=$(mktemp /tmp/octave-XXXX);
#   cat <<EOSCRIPT > "$python_script_tmp"
# #!/usr/bin/env python
# # This is a Python 2.x script, and requires the macOS-specific Cocoa module
# import sys
# import Cocoa
#
# icons_file = sys.argv[1].decode("utf-8")
# oct_gui_file = sys.argv[2].decode("utf-8")
# wksp = Cocoa.NSWorkspace.sharedWorkspace()
# icons_data = Cocoa.NSImage.alloc().initWithContentsOfFile_(icons_file)
# ok = wksp.setIcon_forFile_options_(icons_data, oct_gui_file, 0)
# if not ok:
#   sys.exit("Unable to set file icons for file " + oct_gui_file + " from icons file " + icons_file)
#
# EOSCRIPT
#   # The glob here should produce exactly one file; it's just done for convenience in building the file path
#   # TODO: Replace the glob with an exact path.
#   /usr/bin/python3 "$python_script_tmp" "${APP_BUILD}/Contents/Resources/applet.icns" "${APP_BUILD_USR}/Cellar/${OCTAVE_FORMULA}/*/libexec/octave/*/exec/*/octave-gui"

  # List all included formulae in the VERSIONS file
  local versions_file octave_app_str app_build_brew
  versions_file="${APP_BUILD}/Contents/Resources/VERSIONS"
  rm -f "${versions_file}"
  touch "${versions_file}"
  octave_app_str="Octave.app"
  if [[ -n "$FORMULA_VARIANT" ]]; then
    octave_app_str="${octave_app_str} (variant ${FORMULA_VARIANT})"
  fi
  octave_app_str="${octave_app_str}, version $oct_ver"
  if [[ -n "${BUILD_SUFFIX}" ]]; then
    octave_app_str="${octave_app_str}, build ${BUILD_SUFFIX}"
  fi
  info "Octave.app version: ${octave_app_str}"
  echo "This is ${octave_app_str}" >> "${versions_file}"
  echo "" >> "$versions_file"
  # TODO: Convert to the stashed version of this
  # "$brew" octave-app-list-formulae >> "${versions_file}"
  cat "$formulae_vers_file" >> "$versions_file"

  app_build_brew="${APP_BUILD_USR}/bin/brew"

  # Remove Homebrew itself
  # (So Octave.app users don't use it and accidentally modify their app installation,
  # including if they meant to do stuff in their system Homebrew. It's not about saving
  # space.)
  rm -rf "${APP_BUILD_USR}/Homebrew" \
      "${APP_BUILD_USR}/etc/bash_completion.d/brew" \
      "${APP_BUILD_USR}/share/man/man1/README.md" \
      "${APP_BUILD_USR}/share/man/man1/brew-cask.1" \
      "${APP_BUILD_USR}/share/man/man1/brew.1" \
      "${APP_BUILD_USR}/share/doc/homebrew" \
      "${APP_BUILD_USR}/share/zsh/site-functions/_brew_cask" \
      "${APP_BUILD_USR}/share/zsh/site-functions/_brew" \
      "${APP_BUILD_USR}/bin/brew"

  # Redirect the app prefix's var/ to system local /var
  # Disabled because it seems to break code signing
  # rm -rf "$APP_BUILD_USR/var"
  # ln -s "/usr/local/var" "$APP_BUILD_USR/var"

  # Clear resource fork and Finder information that codesign doesn't like
  # Suppress errors because xattr seems to raise "no such file" errors for files
  # that sure look like they're there.
  # Disabled for now, since we're not doing code signing anyway.
  # xattr -rc "$APP_BUILD" || true

  # Lock down files to prevent accidental modification by users
  chmod -R a-w "${APP_BUILD_USR}/Cellar"
  # But Qt needs to write to the .qhc files and local dirs when running its help
  # viewer (really, Qt?)
  # TODO: Limit this to specific dirs we know should be writable
  find "${APP_BUILD_USR}/Cellar/${OCTAVE_FORMULA}" -name '*.qhc' | xargs chmod u+w
  find "${APP_BUILD_USR}/Cellar/${OCTAVE_FORMULA}" -type d | xargs chmod u+w

  # Remove the STAGING flag file so you can tell it's a real built app now
  rm -rf "${APP_BUILD}/STAGING"

  info "Munging complete. Removed STAGING flag file."
}

function sign_app() {
  # Sign the app bundle using Apple code signing (BROKEN)
  #
  # This currently does not work. It'll run, but the resulting app is not recognized
  # by macOS as signed for me.
  local file_list_file link_dir link link_target real_target codesign_status

  info "Signing the app..."
  info "Using code signing identity ${CODESIGN_IDENTITY}"
  if [[ $DRY_RUN = 'y' ]]; then
    info 'dry run: would sign the app'
    return
  fi

  # Signing apparently must happen in the installation location to make codesign happy
  # with its internal symlinks.
  if [[ -e "$INSTALL_DIR" ]]; then
    die "File exists at ${INSTALL_DIR}. Cannot stage the munged app to sign."
  fi
  wet mv "$APP_BUILD" "$INSTALL_DIR"
  if [[ $ABSOLUTIFY_SYMLINKS == 'y' ]]; then
    # Let's try making all symlinks absolute to get validation to work?
    if [[ $DRY_RUN = 'y' ]]; then
      info 'dry run: would absolutify symlinks'
    else
      file_list_file=$(mktemp /tmp/octave-XXXXX)
      find "$INSTALL_DIR" -type l | sort > "$file_list_file"
      while read link; do
        link_dir=$(dirname "$link")
        link_target=$(readlink "$link")
        (
          cd "$link_dir"
          real_target=$(oa_realpath "$link_target")
          rm "$link"
          ln -s "$real_target" "$link"
        )
      done <${file_list_file}
      rm "$file_list_file"
    fi
  fi
  # Do the actual signing
  if wet codesign --sign "$CODESIGN_IDENTITY" --force -vvvv "$INSTALL_DIR" \
    --timestamp --strip-disallowed-xattrs \
    --file-list "${BUILD_LOG_DIR}/codesign-changed-files.txt"; then
    codesign_status="$?"
    info "codesign returned success"
  else
    codesign_status="$?"
    info "codesign returned failiure: exit status ${codesign_status}"
  fi
  # Verify it, for diagnostics
  echo ""
  info "Verifying app codesigning..."
  info "Verification with 'codesign --display':"
  wet codesign --display -vv "$INSTALL_DIR"
  info "Verification with 'codesign --verify':"
  wet codesign --verify -vv "$INSTALL_DIR"
  info "Verification with 'spctl --assess':"
  wet spctl --assess -vvvv "$INSTALL_DIR"
  if wet spctl --assess -t open --context context:primary-signature -vv "$INSTALL_DIR"; then
    codesign_status="$?"
    error "codesigning assessment failed (exit status $?)"
  fi
  # And move back to the munged build location...
  wet mv "$INSTALL_DIR" "$APP_BUILD"
  if [[ $codesign_status != 0 ]]; then
    die "codesigning failed: codesign returned ${codesign_status}"
  fi
}

function require_app_build() {
  if [[ ! -d "$APP_BUILD" ]]; then
    die "No app build present at $APP_BUILD. Please run the ${THIS_PROGRAM} build and munge steps first."
  fi
}

function create_dmg() {
  # Create a nice DMG disc image with create-dmg
  info "Creating DMG..."
  local octapp_tap_dir
  local install_instr_file='READ ME! - Important Installation Instructions.txt'

  require_app_build
  mkdir -p "$BUILD_DIR"

  # Delete any existing DMG
  if [[ -f "${BUILD_DIR}/${DMG_FILE}" ]]; then
    info "Deleting existing dist DMG at ${BUILD_DIR}/${DMG_FILE}"
    wet rm -rf "${BUILD_DIR}/${DMG_FILE}"
  fi
  info "Creating dist DMG at ${BUILD_DIR}/${DMG_FILE}"

  # Detect tap location, which varies between Intel and AS
  if [[ $MACHINE_ARCH == 'arm64' ]]; then
    # TODO: Fix this path?
    octapp_tap_dir="${INSTALL_BUILT_USR}/Homebrew/Library/Taps/octave-app/homebrew-octave-app"
  else
    octapp_tap_dir="${INSTALL_BUILT_USR}/Homebrew/Library/Taps/octave-app/homebrew-octave-app"
  fi

  # Munge the installation instructions file, to get build-specific names right
  cat "assets/${install_instr_file}.in" \
    | sed -e "s/@@DIST_ARCHIVE_NAME@@/${DIST_ARCHIVE_NAME}/g" \
    > "${BUILD_DIR}"/"${install_instr_file}"


  # Create the installer DMG. This may issue warnings if run headless. However, the DMG
  # will still be created, only some beautification cannot be applied.
  # We manually set the image size because create-dmg's automatic sizing seems to
  # get it wrong, and we run out of space when adding files.
  local app_build_octapp_keg="${APP_BUILD}/Contents/Resources/usr/Cellar/${OCTAVE_FORMULA}/${OCTAVE_FORMULA_VERSION}"
  local createdmg_extra=''
  if [[ $VERBOSE = 'y' ]]; then
    createdmg_extra="${createdmg_extra} --verbose"
  fi
  if [[ $DEBUG_VERBOSE = 'y' ]]; then
    createdmg_extra="${createdmg_extra} --hdiutil-verbose --debug"
  fi
  wet ${SUDO} "${CREATEDMG_HOME}/create-dmg" \
      $createdmg_extra \
      --volname "${DMG_VOLUME_NAME}" \
      --volicon "${APP_BUILD}/Contents/Resources/applet.icns" \
      --filesystem APFS \
      --window-size 550 500 \
      --icon-size 48 \
      --icon "${APP_NAME}.app" 125 180 \
      --hide-extension "${APP_NAME}.app" \
      --app-drop-link 415 180 \
      --eula "${octapp_tap_dir}/assets/COPYING/COPYING.rtf" \
      --add-file "${install_instr_file}" "${BUILD_DIR}/${install_instr_file}" 270 350 \
      --add-file COPYING "${app_build_octapp_keg}/COPYING" 126 300 \
      --add-file VERSIONS "${APP_BUILD}/Contents/Resources/VERSIONS" 415 300 \
      --disk-image-size 7500 \
      --background "${OCTAPPBUNDLER_HOME}/assets/background.tiff" \
      "${BUILD_DIR}/${DMG_FILE}" \
      "$APP_BUILD"
  if is_do_sudo; then
    sudo chown "$USER" "${BUILD_DIR}/${DMG_FILE}"
  fi

  info "DMG ready at: ${BUILD_DIR}/${DMG_FILE}"
}

function test_app() {
  info "Running test suite on built app..."

  if is_dry_run; then
    echo 'dry run: would run test suite'
    return
  fi

  require_app_build
  if [[ -d "$INSTALL_DIR" ]]; then
    die "An Octave.app already exists at '${INSTALL_DIR}'. Please move it out of the way and then try `${THIS_PROGRAM}` test again."
  fi
  mv "$APP_BUILD" "$INSTALL_DIR"
  osascript "${INSTALL_DIR}/Contents/Resources/Scripts/main.scpt" --run-test-suite
  mv "$INSTALL_DIR" "$APP_BUILD"
}

# A dummy "step" that lets you run this whole script and do nothing,
# just to test whether it parses correctly and the option-parsing runs.
function do_debug_parse () {
  info "${THIS_PROGRAM} script parsed OK."
}

# Main program

function do_whole_build_process() {
  local t0
  t0=$(tic)
  stage_app_build
  # Used to do freshen_staged_homebrew automatically here, but I turned that off because
  # I want stability between repeated incremental builds on an existing staged app. Now,
  # if you want to freshen it, manually invoke the freshen_staged_homebrew step.
  # Actually, oops, need to still do this for now: freshen_staged_homebrew() doesn't just
  # update an existing Homebrew install; it's the thing that creates the new Homebrew
  # install in the first place.
  # TODO: Split this out to separate "ensure" (create if not exist) and "update/freshen" (do
  # updates and upgrades on existing Homebrew install) operations.
  freshen_staged_homebrew
  timeit build_octave_in_staged_app build_octave_in_staged_app
  timeit capture_built_octave_app capture_built_octave_app
  unstage_app_build
  munge_build
  if [[ "$DO_SIGN" == "y" ]]; then
    sign_app
  fi
  if [[ "$DO_BUILD_DMG" == "y" ]]; then
    timeit create_dmg create_dmg
  fi
  info "Build finished."
  say_toc "whole_build" "$t0"
}

function parse_cli_args() {
  local arg

  REMAINDER_ARGS=()
  while [[ $# -ge 1 ]]; do
    arg="$1"; shift
    case "$arg" in
      -a | --variant)
        parse_cli_opt_needs_arg "$#" "$arg"
        FORMULA_VARIANT="$1";
        RELEASE_VARIANT="$1";
        shift ;;
      --formula-variant)
        FORMULA_VARIANT="$1"; shift ;;
      --release-variant)
        RELEASE_VARIANT="$1"; shift ;;
      -d | --build-devel)
        DO_BUILD_DEVEL=y ;;
      -f | --octave-formula)
        parse_cli_opt_needs_arg "$#" "$arg"
        OCTAVE_FORMULA_BASE="$1"; shift ;;
      -V | --octave-version)
        parse_cli_opt_needs_arg "$#" "$arg"
        OCTAVE_FORMULA_VERSION="$1"; shift ;;
      -g | --use-gcc)
        USE_GCC=y ;;
      -h | --help| -\?)
        usage; exit 0 ;;
      -s | --step)
        parse_cli_opt_needs_arg "$#" "$arg"
        BUILD_STEP="$1"; shift ;;
      -S | --all-from-source)
        BUILD_ALL_FROM_SOURCE=y ;;
      --sign)
        DO_SIGN=y ;;
      --sign-identity)
        CODESIGN_IDENTITY="$1"; shift ;;
      --tap-branch)
        OCTAPP_TAP_BRANCH="$1"; shift ;;
      -u | --build-suffix)
        parse_cli_opt_needs_arg "$#" "$arg"
        BUILD_SUFFIX="$1"; shift ;;
      --pre-release)
        parse_cli_opt_needs_arg "$#" "$arg"
        PRE_RELEASE="$1"; shift ;;
      --update-release)
        parse_cli_opt_needs_arg "$#" "$arg"
        UPDATE_RELEASE="$1"; shift ;;
      --no-sudo)
        USE_SUDO=n ;;
      -v | --verbose)
        VERBOSE=y ;;
      -x | --trace)
        DO_TRACE=y ;;
      --show-options)
        DO_JUST_SHOW_OPTIONS=y ;;
      -Y | --dry-run)
        DRY_RUN=y ;;
      --debug-no-errexit)
        EXIT_ON_ERROR=n ;;
      --debug-verbose)
        DEBUG_VERBOSE=y ;;
      --)
        REMAINDER_ARGS=("$@")
        break ;;
      brew)
        ACTION="$arg"
        REMAINDER_ARGS=("$@")
        break ;;
      *)
        die "invalid option: ${arg}. See ${THIS_PROGRAM} --help for help." ;;
    esac
  done

  # Handle inter-option interaction and consistency stuff
  local n_suffixes=0 x
  local -a suffix_vals
  suffix_vals=("$BUILD_SUFFIX" "$PRE_RELEASE" "$UPDATE_RELEASE")
  for x in "${suffix_vals[@]}"; do
    if [[ -n "$x" ]]; then
      n_suffixes=$(( n_suffixes + 1 ))
    fi
  done
  if [[ $n_suffixes > 1 ]]; then
    die "Only one of --build-suffix, --prerelease, or --update-release may be given; got $n_suffixes of them"
  fi

  if [[ -n "$PRE_RELEASE" ]]; then
    BUILD_SUFFIX="$PRE_RELEASE"
    DO_BUILD_SUFFIX_IN_APP_NAME=y
  fi
  if [[ -n "$UPDATE_RELEASE" ]]; then
    BUILD_SUFFIX="$UPDATE_RELEASE"
    DO_BUILD_SUFFIX_IN_APP_NAME=n
  fi
}

function parse_cli_opt_needs_arg() {
  local nargs="$1" arg="$2"
  if [[ $nargs -lt 1 ]]; then
    die "option ${arg} requires an argument"
  fi
}

function main () {
  local exit_status

  # Code setup
  enable_errexit

  info "Building ${APP_NAME}.app from brew formula ${OCTAVE_FORMULA} to ${INSTALL_DIR}, build label ${BUILD_LABEL}"
  export HOMEBREW_LOGS="${BUILD_LOG_DIR}/brew"
  wet mkdir -p "$BUILD_LOG_DIR"
  wet mkdir -p "$BUILD_LOG_DIR/brew"

  # Handle special actions first (each of these should exit when done)
  if [[ -n "$ACTION" ]]; then
    case "$ACTION" in
      brew)
        disable_errexit
        stage_app_build
        info "Running brew command: ${brew} ${REMAINDER_ARGS[@]}"
        "$brew" "${REMAINDER_ARGS[@]}"
        exit_status=$?
        info "brew exit status: ${exit_status}"
        unstage_app_build
        exit $exit_status
        ;;
      *)
        die "Invalid special action: '$ACTION'. Valid special actions are: brew"
        ;;
    esac
    die "BUG: special action '$ACTION' did not exit the program"
  fi

  # Main build process
  if [[ -z "$BUILD_STEP" ]]; then
    do_whole_build_process 2>&1 | tee "${BUILD_LOG_DIR}/bundle_octapp.log"
  else
    # Run a single step
    info "Running single build step: $BUILD_STEP"
    case "$BUILD_STEP" in
      stage)            stage_app_build ;;
      unstage)          unstage_app_build ;;
      freshen-homebrew) freshen_staged_homebrew ;;
      build)            build_octave_in_staged_app 2>&1 | tee "${BUILD_LOG_DIR}/bundle_octapp.log" ;;
      capture)          capture_built_octave_app ;;
      capture-logs)     capture_build_logs ;;
      munge)            munge_build ;;
      sign)             sign_app ;;
      createdmg)        create_dmg ;;
      test)             test_app ;;
      # Undocumented debugging "steps"
      debug-parse)      do_debug_parse ;;
      *)
        die "Invalid build step: ${BUILD_STEP}. Valid steps are: stage unstage freshen-homebrew build munge sign dmg test"
        ;;
    esac
  fi
}

# Main top-level code

# Vars which do not depend on picked names or detected dependencies
function init_global_vars() {
  # "Constants" and configuration stuff
  #
  # These may be used in only one place, so they could be locals inside functions, but I like to have the definitions
  # of these things all grouped together
  MACHINE_ARCH=$(uname -m)
  if [[ $MACHINE_ARCH = 'x86_64' ]]; then
    MACHINE_ARCH_DESCR='Intel'
  elif [[ $MACHINE_ARCH = 'arm64' ]]; then
    MACHINE_ARCH_DESCR='Apple Silicon'
  else
    MACHINE_ARCH_DESCR="$MACHINE_ARCH"
  fi
  # Large deps only needed at Octave.app build time only (not oct-file/mex-file build time
  # at Octave.app run time) to remove to save space
  BIG_BUILD_ONLY_PKGS=(rust llvm llvm@17)

  # Controls for what gets built

  # Default version to build. This is updated frequently to match the latest version of Octave.app
  # we're currently working on.
  DEFAULT_OCTAVE_FORMULA_VERSION="8.4.0"
  FORMULA_VARIANT=
  RELEASE_VARIANT=
  BUILD_SUFFIX=
  PRE_RELEASE=
  UPDATE_RELEASE=
  # Whether the build suffix is included in the app name, which is the end-user-visible name used
  # in the "Octave-*.app" file name, and other user-visible places. Generally, turn this on when
  # doing beta and other prerelease or testing builds, and turn it off for real releases, including
  # "u1" updates and the like. The --pre-release and --update-release options (instead of the generic
  # --build-suffix option) will handle this for you.
  DO_BUILD_SUFFIX_IN_APP_NAME=n
  DO_BUILD_DEVEL=n
  DO_SIGN=n
  DO_JUST_SHOW_OPTIONS=n
  CODESIGN_IDENTITY='Andrew Janke (R7H2BFWJAB)'
  ABSOLUTIFY_SYMLINKS=n
  # Define these if we need to use a special branch of Homebrew
  BREW_REMOTE_URL=
  BREW_REMOTE_BRANCH=
  # Use an alternate branch of the octave-app tap for the octapp formulae, instead of main
  OCTAPP_TAP_BRANCH=
  DO_BUILD_DMG=y
  USE_GCC=n
  BUILD_ALL_FROM_SOURCE=n

  # Controls for how this bundle_octave_app execution runs
  ACTION=
  BUILD_STEP=
  DO_SIGN=n
  VERBOSE=n
  DEBUG_VERBOSE=n
  EXIT_ON_ERROR=y
  DO_TRACE=n
  BUILD_TIMESTAMP=$(date +%Y-%m-%d_%H-%M-%S)
  BUILD_DIR="./build"
  # An only-locally-meaningful label to distinguish build operations for log location etc.
  BUILD_LABEL="octapp_build_${BUILD_TIMESTAMP}"
  BUILD_LOG_DIR="${BUILD_DIR}/logs/${BUILD_LABEL}"
  DRY_RUN=
  USE_SUDO=y

  OCTAPPBUNDLER_HOME=$(dirname $0)
  MACHINE_MACOS_VER=$(sw_vers -productVersion)
  MACHINE_MACOS_VER_MAJMIN=$(sw_vers -productVersion | sed -E 's/^(\w+\.\w+).*/\1/')
}

init_global_vars
parse_cli_args "$@"
if [[ "$DO_TRACE" == "y" ]]; then
  set -o xtrace
fi
pick_names_for_things

# Here, SUDO is a "command list" variable that should not be quoted
if [[ $USE_SUDO == 'y' ]]; then
  SUDO='sudo'
else
  SUDO=''
fi

# Dep detection must come before show_options, which shows its results and thus needs it
detect_tool_dependencies

# Vars that do depend on chosen names and/or detected dependencies
INSTALL_DIR="/Applications/${APP_NAME}.app"
INSTALL_BUILT="/Applications/${APP_NAME}-BUILT.app"
INSTALL_DIR_UNSTAGED="${INSTALL_DIR}-UNSTAGED"
INSTALL_USR="${INSTALL_DIR}/Contents/Resources/usr"
INSTALL_BUILT_USR="${INSTALL_BUILT}/Contents/Resources/usr"
brew="${INSTALL_USR}/bin/brew"
APP_BUILD="${BUILD_DIR}/${APP_NAME}.app"
APP_BUILD_USR="${APP_BUILD}/Contents/Resources/usr"

setup_brew_env

if [[ "$VERBOSE" == "y" || "$DO_JUST_SHOW_OPTIONS" == "y" ]]; then
  show_options
fi
if [[ "$DO_JUST_SHOW_OPTIONS" == "y" ]]; then
  exit 0
fi

# Pick up commands from octapp build. This is (I think) just a hack to pick up
# Subversion's svn command, so this tool can be run on computers without a system-wide
# Homebrew or MacPorts installation to supply svn.
# TODO: Maybe drop this and add a dependency on a system svn? It'll pick up a bunch
# of other commands too, which isn't good for repeatability. Or maybe it's because
# the brew installs may need commands from the Homebrew installation? In which case we
# need to keep this. Either way, document it.
PATH="${INSTALL_USR}/bin/:$PATH"

# TODO: This early exit needs to go away once dry-run support in the various steps
# is working.
if is_dry_run; then
  info
  info "DRY RUN: Not actually doing anything."
  info
  exit 0
fi

main
