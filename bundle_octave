#!/usr/bin/env bash

# bundle_octave - Create an Octave.app app bundle
#
# Hints:
#
# If you want to do your compilations single-threaded, which will be slower
# but produce more readable output, set the environment variable
# HOMEBREW_MAKE_JOBS=1 before running bundle_octave.

# Style note: Most variables in this script are globals, but they're in
# lower case anyway, for readability and aesthetics.

# TODO: Support for alternate branches of the octave-app tap, so we can build using
# formulae there as a way of testing them before merging to main.
# Note: Older versions of this had support for explicit build architectures (using
# $build_arch), but that disappeared as of 2021. May need to re-add it to support
# older Macs.

# TODO: This is breaking again due to netpbm needing svn to download its source code
# when installing to an alternate prefix.
#
# ==> Cloning https://svn.code.sf.net/p/netpbm/code/stable
# ==> Checking out 4686
# You must: brew install svn
# Error: octave-octave-app@8.3.0: Failed to download resource "netpbm"

# TODO: Fix this "python not found" error at the end of the build. Might be as simple as
# using 'python3' instead, since that exists on macOS 12 and 14.
#
# For pkg-config to find octave-octave-app@8.3.0 you may need to set:
#   export PKG_CONFIG_PATH="/Applications/Octave-8.3.0.app/Contents/Resources/usr/opt/octave-octave-app@8.3.0/lib/pkgconfig"
# Uninstalling /Applications/Octave-8.3.0.app/Contents/Resources/usr/Cellar/rust/1.72.1... (38,925 files, 853.2MB)
# Munging app build at ./build/Octave-8.3.0.app
# Octave versions: ver='8.3.0' ver_string='GNU Octave, version 8.3.0' copy='1993-2023 The Octave Project Developers.'
# ./bundle_octave: line 695: /usr/bin/python: No such file or directory

# TODO: version style controls for app name
#   # valid: 'major', 'minor', 'patch', 'full', or 'none'
#   appname_ver_style='minor'
# TODO: Also, spaces in app name instead of dashes
# TODO: Also, an "x64" in the app name for Intel builds
# TODO: Which means we need a way to detect whether we're running on Intel or AS

set -o errexit
# set -o nounset  # fails due to arg parsing technique that needs to be fixed
set -o pipefail
if [[ "${TRACE-0}" == "1" ]]; then set -o xtrace; fi

# Default stuff to build. This is updated frequently to match the latest version of Octave.app
# we're currently working on.
default_octave_formula_version="8.3.0"
# This should be 'alpha1' right now, but I'm temporarily using a no-suffix build name so I
# can reuse the partial build I have on eilonwy, which would take a couple hours to rebuild.
# default_build_suffix='alpha1'
default_build_suffix=''
# Whether the build suffix is included in the app name, which is the end-user-visible name used
# in the "Octave-*.app" file name, and other user-visible places. Generally, turn this on when
# doing beta and other prerelease or testing builds, and turn it off for real releases, including
# "u1" updates and the like.
do_build_suffix_in_app_name=y

# Controls for what gets built
build_suffix="$default_build_suffix"
build_gui=y
use_java=y
use_desktop=y
variant=""
build_devel=n
codesign_author_name="Andrew Janke"
# Define these if we need to use a special branch of Homebrew
brew_remote_name=
brew_remote_url=
brew_remote_branch=
# Define this if you need an alternate branch of the octave-app tap for the octapp formulae
octapp_tap_branch='new-2023-versions'

# Controls for how this bundle_octave execution runs
action=
build_step=""
build_dmg=y
do_sign=n
verbose=n
exit_on_error=y
do_trace=n

this_program=$(basename $0)
bundler_home=$(dirname $0)

function die() {
  local msg="$1"
  echo >&2 "${this_program}: ERROR: $1"
  exit 1
}

# Build-time dependencies on system-installed programs. We use system-installed ones instead
# of installing them in to Octave.app to avoid bloating the app.
if ! which gsed >/dev/null; then
  die "Could not find gsed. This tool requires gsed, not just regular (BSD) sed."
fi
if ! which python3 >/dev/null; then
  die "Could not find python3. This tool requires Python 3.x, and the command must be 'python3' and not just 'python'."
fi
# Not requiring svn for now because we're installing it inside the app to make brew happy
# if ! which svn >/dev/null; then
#   die "Could not find svn. This tool requires Subversion to be installed on your machine."
# fi

this_macos_ver_majmin=$(sw_vers -productVersion | gsed -E 's/^(\w+\.\w+).*/\1/')

function usage() {

  cat <<EOHELP
  ${this_program}
  ${this_program} [OPTION [ARG]] ...
  ${this_program} brew <brew_args ...>

  Build an Octave.app application bundle for macOS.

  The '${this_program} brew ...' calling form runs an arbitrary 'brew' command in the Homebrew
  installation inside the staged app bundle.

  All other calling forms do regular build operations.

  Several options are supported:

    Packaging options:
      -u, --build-suffix <suffix>
        Set a build version suffix. Used to distinguish revisions and updates
        to Octave.app's packaging, like 'u1' or 'u2'. This can be used for beta builds, too,
        like `-u beta1`. [$build_suffix]
      -t, --with-test
        Do not run tests on completed app.
      --sign
        Sign the completed app bundle.

    Octave build options:
      -a, --variant <variant>
        Variant of Octave.app to build [$variant].
      -V, --octave-version <version>
        Version of Octave formula to build (affects formula choice) [$octave_version].
      -c, --cli-only
        Do not build the GUI.
      -C, --cli-frontend
        Use the CLI as the front end, while still building graphics/Qt support.
      -J, --no-java
        Compile without Java support.
      -d, --build-devel
        Build the latest Octave development snapshot instead of a released version.

    Debugging options:
      -h, -?, --help
        Display this help text.
      -s, --step <step>
        Run a single step of the build process (for debugging use).
      -v, --verbose
        Verbose output, and list state of all options.
      -x, --trace
        Trace program execution (even more detail than --verbose). You can also set the
        TRACE=1 environment variable to get the same effect.
      -e, --exit-on-errors
        Exit on errors. This is now on by default, though it was off in older versions.
      -y, --dry-run
        Compute values but do not actually build.

EOHELP
}

while [[ "${1-}" != "" ]]; do
  case "$1" in
    -a|--variant)
      if [[ $# -gt 1 ]]; then
        variant=$2; shift 2
      else
        die "option $1 requires an argument"
      fi ;;
    -c|--cli-only)
      build_gui=n; shift 1 ;;
    -C|--cli-frontend)
      use_desktop=n; shift 1 ;;
    -d|--build-devel)
      build_devel=y; shift 1 ;;
    -E|--ignore-errors)
      exit_on_error=n; shift 1 ;;
    -f|--octave-formula)
      if [[ $# -gt 1 ]]; then
        octave_formula_base=$2; shift 2
      else
        die "option $1 requires an argument"
      fi ;;
    -g|--use-gcc)
      use_gcc=y; shift 1 ;;
    -h|--help|-\?)
      usage; exit 0 ;;
    -J|--no-java)
      use_java=n; shift 1 ;;
    -s|--step)
      if [[ $# -gt 1 ]]; then
        build_step=$2; shift 2
      else
        die "option $1 requires an argument"
      fi ;;
    --sign) do_sign=y; shift 1 ;;
    -u|--build-suffix)
        if [[ $# -gt 1 ]]; then
          build_suffix=$2; shift 2
        else
          die "option $1 requires an argument"
        fi ;;
    -v|--verbose) verbose=y; shift 1 ;;
    -V|--octave-version)
        if [[ $# -gt 1 ]]; then
          octave_formula_version=$2; shift 2
        else
          die "option $1 requires an argument"
        fi ;;
    -x|--trace)
      do_trace=y; shift 1 ;;
    -y|--dry-run)
      do_dry_run=y; shift 1 ;;
    --)
      shift
      break ;;
    brew)
      action="brew"
      shift 1
      break
      ;;
    *)
      echo >&2 "Error: Invalid option: $1"
      echo >&2 "See ${this_program} --help for help."
      exit 1
      ;;
  esac
done

function echo_options() {
  cat <<EOS
Options:
variant = ${variant}
octave_formula_version = ${octave_formula_version}
build_suffix = ${build_suffix}
build_gui = ${build_gui}
build_devel = ${build_devel}
build_dmg = ${build_gui}
dmg_dir = ${dmg_dir}
use_gcc = ${use_gcc}
use_java = ${use_java}
octave_app_bundler_home = ${bundler_home}
use_desktop = ${use_desktop}

EOS
}

if [[ "$exit_on_error" = "y" ]]; then
  set -o errexit
else
  set +o errexit
fi
if [[ "$verbose" == "y" ]]; then
  echo_options
fi
if [[ "$do_trace" == "y" ]]; then
  set -o xtrace
fi

# Bash 3 does not have associative arrays, so we need to do the version lookup with a
# function. (MacOS is stuck on Bash 3.x for GPL licensing reasons.)
#
# The octave_version is a version number of a main Octave release, in "x.y.z" form. The
# octave_formula_version is an Octave.app-specific thing which may include suffixes like "_u1"
# to indicate different Octave.app builds or definitions that use the same Octave release.
function pick_default_octave_version() {
  if [[ "$octave_formula_base" == "octave-octave-app" ]]; then
    octave_formula_version="$default_octave_formula_version"
    octave_version="${octave_formula_version//_[[:digit:]]/}"
  elif [[ "$octave_formula_base" == "octave-unversioned" ]]; then
    octave_version=""
    octave_formula_version=""
  else
    die "Variant '${variant}' has no default version defined. You must supply one." >&2
  fi
}

# Calculate all our various names

if [[ -z "$variant" ]]; then
  octave_formula_base="octave-octave-app"
  app_base_name_base="octave"
else
  octave_formula_base="octave-${variant}"
  app_base_name_base="${octave_formula_base}"
fi
app_base_name="$(tr '[:lower:]' '[:upper:]' <<< ${app_base_name_base:0:1})${app_base_name_base:1}"
# Pick default version for variant
if [[ -z "${octave_formula_version}" ]]; then
  pick_default_octave_version
else
  octave_version="${octave_formula_version//_[[:digit:]]/}"
fi
if [[ -z "$variant" ]]; then
  version_name="${octave_version}"
else
  version_name="${octave_version}-${variant}"
fi
if [[ -z "$octave_formula_version" ]]; then
  octave_formula="${octave_formula_base}"
else
  octave_formula="${octave_formula_base}@${octave_formula_version}"
fi
if [[ -z "$octave_version" ]]; then
  app_name="${app_base_name}"
else
  app_name="${app_base_name}-${octave_version}"
fi
if [[ -z "$build_suffix" ]]; then
  oapp_release="${version_name}"
  app_name_with_release="${app_name}"
  volume_name="${app_base_name} ${octave_version}"
else
  oapp_release="${version_name}-${build_suffix}"
  app_name_with_release="${app_name}-${build_suffix}"
  volume_name="${app_base_name} ${octave_version} ${build_suffix}"
  if [[ "$do_build_suffix_in_app_name" = y ]]; then
    app_name="${app_name}_${build_suffix}"
  fi
fi
dmg_name="${app_name_with_release}.dmg"
install_dir="/Applications/${app_name}.app"
install_dir_unstaged="${install_dir}-UNSTAGED"

install_usr="$install_dir/Contents/Resources/usr"
brew="$install_usr/bin/brew"
app_build="./build/${app_name}.app"
app_build_usr="$app_build/Contents/Resources/usr"

echo "Building ${app_name}.app at ${install_dir} from formula ${octave_formula}"

if [[ -n "$do_dry_run" ]]; then
  echo "${this_program}: DRY RUN: not actually doing anything."
  exit 0
fi

# set some environment variables
PATH="${install_usr}/bin/:$PATH"

function stage_app_build() {
  if [[ -e "$install_dir" ]]; then
    if [[ -f "${install_dir}/STAGING" ]]; then
      echo "Looks like $app_name is already staged; re-using in place"
    else
      echo "Error: ${install_dir} exists, but is not a staged build." >&2
      echo "Error: Please move ${install_dir} out of the way before running ${this_program}" >&2
      exit 1
    fi
  elif [[ -e "$install_dir_unstaged" ]]; then
    echo "Re-staging existing build dir from ${install_dir_unstaged}"
    mv "$install_dir_unstaged" "$install_dir"
  else
    # Create new staged app
    echo "Creating new staged app build at ${install_dir}"
    osacompile -o "$install_dir" -e " "
    cat <<EOS > "$install_dir/STAGING"
This directory is not a real app!

This is a staged build for octave-app-bundler. If you found this at ${install_dir},
then there was probably a failed build, and this directory needs to be manually
deleted or moved aside.
EOS
  fi
}

function unstage_app_build() {
  if [[ ! -e "${install_dir}/STAGING" ]]; then
    die "Error: ${install_dir} does not look like a staged build. Not moving."
  fi
  if [[ -e "${install_dir_unstaged}" ]]; then
    die "Error: There is already an unstaged app build at ${install_dir_unstaged}. Cannot un-stage."
  fi
  mv "$install_dir" "$install_dir_unstaged"
  echo "Un-staged build to ${install_dir_unstaged}"
}

function require_staged_app_build() {
  if [[ ! -f "${install_dir}/STAGING" ]]; then
    echo >&2 "Error: This step requires a staged app build, but there is no app build staged at ${install_dir}."
    if [[ -n "$build_step" ]]; then
      echo >&2 "Error: Please run '${this_program} -s stage' to stage an app build and then retry."
    fi
    exit 1
  fi
}

function freshen_staged_homebrew() {
  require_staged_app_build
  # Check if we do full or update
  if [[ -e "${install_usr}/bin/brew" ]]; then
    install_type='update'
  else
    install_type='full'
  fi

  if [[ "$install_type" == "update" ]]; then
    # Update homebrew
    echo "Updating existing Homebrew installation in ${install_usr}"
  else
    # Install homebrew
    echo "Creating new Homebrew installation in ${install_usr}"
    mkdir -p "${install_usr}/bin" "${install_usr}/var" "${install_usr}/lib"
    git clone https://github.com/Homebrew/brew "${install_usr}/Homebrew"
    ln -s "${install_usr}/Homebrew/bin/brew" "${install_usr}/bin/brew"
    if [[ -n "$brew_remote_branch" ]]; then
      (
        echo "Checking out Homebrew branch ${brew_remote_branch} from remote ${brew_remote_url}"
        "$brew" update
        cd "${install_usr}/Homebrew"
        git remote add "$brew_remote_name" "$brew_remote_url"
        git fetch --all
        git checkout "$brew_remote_branch"
      )
    fi
    "$brew" tap octave-app/octave-app
    if [[ -n "$octapp_tap_branch" ]]; then
      (
        echo "Checking out octave-app tap branch ${octapp_tap_branch}"
        "$brew" update
        # TODO: support new AS dir layout
        cd "${install_usr}/Homebrew/Library/Taps/octave-app/homebrew-octave-app"
        git fetch --all
        git checkout "$octapp_tap_branch"
      )
    fi
    echo "Installing special required build-time packages"
    # svn is needed to fetch the netpbm source
    # TODO: Could this be fixed by adding a build-time dependency on svn to the netpbm formula?
    # TODO: Better yet, can we just require a system-level svn? Doesn't seem to work when done
    # in a separate Homebrew installation (maybe due to brew's environment isolation), so for
    # now, install it in Octave.app and let it bloat up. If we have to do it this way, then we
    # should maybe add subversion and its exclusive deps to the list of packages to prune later.
    "$brew" install subversion
  fi

  "$brew" update # get new formulae
  "$brew" upgrade # compile new formulae
  "$brew" cleanup # remove old versions

  # Force conservative architecture builds in ENV
  SED='/usr/bin/sed'
  $SED -E -i '' "s/ARGV.build_bottle./true/g" "${install_usr}/Homebrew/Library/Homebrew/extend/ENV/super.rb"
  $SED -E -i '' "s/ARGV.build_bottle./true/g" "${install_usr}/Homebrew/Library/Homebrew/extend/ENV/std.rb"
}

function build_octave() {
  require_staged_app_build
  # Set FC to point to GCC's gfortran
  export FC="${install_usr}/bin/gfortran"

  # Use GCC for all scientific libraries
  if [[ "$use_gcc" == "y" ]]; then
    export HOMEBREW_CC=gcc-6
    export HOMEBREW_CXX=g++-6
  fi

  # Work around broken Qt 5.12.1 bottle by forcing from-source install
  # See https://github.com/octave-app/octave-app-bundler/issues/78
  # This should probably be conditionally enabled by detecting which
  # version of Qt we're building against.
  #echo ""
  #echo "Pre-installing Qt to avoid Qt 5.12 bottle breakage"
  #echo "$brew" install -s qt
  #"$brew" install -s qt

  # Build octave
  octave_build_options=""
  if [[ "$verbose" == "y" ]]; then
    octave_build_options="$octave_build_options --verbose"
  fi
  if [[ "$build_devel" == "y" ]]; then
    octave_build_options="$octave_build_options --HEAD"
  fi
  if [[ "$build_gui" != "y" ]]; then
    octave_build_options="$octave_build_options --without-qt"
  fi
  if [[ "$use_java" != "y" ]]; then
    octave_build_options="$octave_build_options --without-java"
  fi
  echo "$brew" install $octave_formula $octave_build_options
  "$brew" install $octave_formula $octave_build_options

  # HACK: remove large build-time-only dependencies to reduce app size
  if "$brew" list --formula | grep rust >/dev/null; then
    "$brew" rm rust
  fi

  # Grab the logs
  rm -rf build/logs
  mkdir -p build/logs
  if [[ -e "$HOME/Library/Logs/Homebrew/${octave_formula}" ]]; then
    cp -pR "$HOME/Library/Logs/Homebrew/${octave_formula}" build/logs
  fi
  if [[ -e "$install_usr/opt/$octave_formula/make-check.log" ]]; then
    cp "$install_usr/opt/$octave_formula/make-check.log" build/logs
  fi
}

function munge_build() {
  require_staged_app_build
  echo "Munging app build at ${app_build}"
  # Get versions dynamically from the built program
  octave="$install_usr/opt/$octave_formula/bin/octave"
  # x.y.z semver-ish version string
  oct_ver="$("$octave" --version | /usr/bin/sed -n 1p | /usr/bin/grep -o '\d\..*$' )"
  oct_ver_string="$("$octave" --version | /usr/bin/sed -n 1p)"
  oct_copyright="$("$octave" --version | /usr/bin/sed -n 2p | /usr/bin/cut -c 15- )"

  echo "Octave versions: ver='${oct_ver}' ver_string='${oct_ver_string}' copy='${oct_copyright}'"

  # Detect and set path for ghostscript
  gs_formula="ghostscript"
  gs_ver="$("${install_usr}/bin/gs" --version)"
  gs_opt=$("$brew" --prefix "$gs_formula")
  gs_share="${gs_opt}/share/ghostscript"

  # Make a local copy for munging, clobbering any existing copy
  mkdir -p build
  if [[ -e "$app_build" ]]; then
    chmod -R u+w "$app_build"
    rm -rf "$app_build"
  fi
  cp -pR "$install_dir" build

  # Use local font cache instead of global one
  /usr/bin/sed -i '' 's/\/Applications.*fontconfig/~\/.cache\/fontconfig/g' "$app_build_usr/etc/fonts/fonts.conf"

  # App-specific startup configuration
  keg="${app_build_usr}/Cellar/${octave_formula}/${octave_version}"
  cat >>"${keg}/share/octave/site/m/startup/octaverc" <<EOS

% Octave.app special configuration

% Use a distinct version-specific package dir to avoid crashes with compiled packages
% (Because compiled oct-files have linkage dependency on the exact path to the Octave installation.)
default_pkg_prefix = pkg ("prefix");
octave_app_pkg_prefix = [getenv("HOME") "/Library/Application Support/Octave.app/${version_name}/pkg"];
% Create the directory ourselves to avoid a warning in the console
mkdir (octave_app_pkg_prefix);
pkg ("prefix", octave_app_pkg_prefix, octave_app_pkg_prefix);
pkg ("local_list", [octave_app_pkg_prefix "/octave_packages"]);
clear default_pkg_prefix octave_app_pkg_prefix

% End Octave.app special configuration

EOS

  # Drop a build version indicator
  echo "$oapp_release" > "${keg}/share/octave/site/Octave.app-RELEASE.txt"

  # Custom functions
  cp -R Mcode/* "${keg}/share/octave/site/m"

  # Create applescript to execute octave
  local tmp_script=$(mktemp /tmp/octave-XXXX)
  if [[ "$build_gui" == "y" ]]; then
    read -r -d '' program_launch_code <<EOS || true
    set cmd to env_setup_cmd() & run_octave_gui()
    do shell script cmd
EOS
  else
    read -r -d '' program_launch_code <<EOS || true
    set cmd to env_setup_cmd() & run_octave_cli()
    tell application "Terminal"
      activate
      do script cmd
    end tell
EOS
  fi
  cat <<EOSCRIPT >> $tmp_script
  on env_setup_cmd()
    export_lang() & export_gs_options() & export_gnuplot() & export_fc() & export_path() & export_dyld()
  end env_setup_cmd

  on export_lang()
    return "default_lang=\$(osascript -e 'user locale of (get system info)'); export LANG=\$default_lang.UTF-8;"
  end export_lang

  on export_gs_options()
    return "export GS_OPTIONS=\\"-sICCProfilesDir=${gs_share}/${gs_ver}/iccprofiles/ -sGenericResourceDir=${gs_share}/${gs_ver}/Resource/ -sFontResourceDir=${gs_share}/${gs_ver}/Resource/Font\\";"
  end export_gs_options

  on export_gnuplot()
    return "export GNUTERM=\\"qt\\"; export PATH=\\"${install_usr}/opt/gnuplot-octave-app/bin:\$PATH\\";"
  end export_gnuplot

  on export_path()
    return "export PATH=\\"${install_usr}/bin/:\$PATH\\";"
  end export_path

  on export_dyld()
    return "export DYLD_FALLBACK_LIBRARY_PATH=\\"${install_usr}/lib:/lib:/usr/lib\\";"
  end export_dyld

  on export_fc()
    return "export FC=\\"${install_usr}/bin/gfortran\\"; export F77=\\"${install_usr}/bin/gfortran\\";"
  end export_fc

  on cache_fontconfig()
    set fileTarget to (path to home folder as text) & ".cache:fontconfig"
    try
      fileTarget as alias
    on error
      display dialog "Font cache not found, so first plotting will be slow. Create font cache now?" with icon caution buttons {"Yes", "No"}
      if button returned of result = "Yes" then
        do shell script "${install_usr}/bin/fc-cache -frv;"
      end if
    end try
  end cache_fontconfig

  on run_octave_gui()
    return "cd ~; clear; ${install_usr}/opt/${octave_formula}/bin/octave -q --gui | logger 2>&1;"
  end run_octave_gui

  on run_octave_cli()
    return "cd ~; clear; ${install_usr}/opt/${octave_formula}/bin/octave -q; exit;"
  end run_octave_cli

  on run_octave_test_suite()
    return "cd ~; clear; ${install_usr}/opt/${octave_formula}/bin/octave --no-window-system --eval '__run_test_suite__' > ~/octave-app-fntest.log 2>&1; exit;"
  end run_octave_test_suite

  on run_octave_open(filename)
    return "cd ~; clear; ${install_usr}/opt/${octave_formula}/bin/octave -q --persist --eval \\"edit " & filename & "\\" | logger 2>&1;"
  end run_octave_open

  on path_check()
    if not (POSIX path of (path to me) starts with "${install_dir}") then
      display dialog "Please run Octave from the ${install_dir} folder" with icon stop with title "Error" buttons {"OK"}
      error number -128
    end if
  end path_check

EOSCRIPT
  if [[ "$use_desktop" = "y" ]]; then
    cat <<EOSCRIPT >> "$tmp_script"
  on open argv
    path_check()
    cache_fontconfig()
    set filename to "\\"" & POSIX path of item 1 of argv & "\\""
    set cmd to env_setup_cmd() & run_octave_open(filename)
    do shell script cmd
  end open

  on run argv
    path_check()
    cache_fontconfig()
    if argv contains "--run-test-suite" then
      set cmd to env_setup_cmd() & run_octave_test_suite()
      do shell script cmd
    else
      ${program_launch_code}
    end
  end run

EOSCRIPT
  else
    cat <<EOSCRIPT >> "$tmp_script"
  on open argv
    path_check()
    cache_fontconfig()
    set filename to "\\"" & POSIX path of item 1 of argv & "\\""
    set cmd to env_setup_cmd() & run_octave_open(filename)
    tell application "Terminal"
      activate
      do script cmd
    end tell
  end open

  on run argv
    path_check()
    cache_fontconfig()
    set cmd to env_setup_cmd() & run_octave_cli()
    tell application "Terminal"
      activate
      do script cmd
    end tell
  end run

EOSCRIPT
  fi

  osacompile -o "${app_build}/Contents/Resources/Scripts/main.scpt" "$tmp_script"
  rm "$tmp_script"

  # Create a nice iconset (using the icons shipped with Octave)
  # The following might fail for the development version; TODO: conditionalize or trap the error
  hicolor_dir="${app_build_usr}/opt/${octave_formula}/share/icons/hicolor"
  svg_icon="${hicolor_dir}/scalable/apps/octave.svg"
  tmp_iconset="$(mktemp -d /tmp/iconset-XXXX)/droplet.iconset"
  mkdir -p "$tmp_iconset"
  cp "${hicolor_dir}/16x16/apps/octave.png" "${tmp_iconset}/icon_16x16.png"
  cp "${hicolor_dir}/32x32/apps/octave.png" "${tmp_iconset}/icon_16x16@2x.png"
  cp "${hicolor_dir}/32x32/apps/octave.png" "${tmp_iconset}/icon_32x32.png"
  cp "${hicolor_dir}/64x64/apps/octave.png" "${tmp_iconset}/icon_32x32@2x.png"
  cp "${hicolor_dir}/128x128/apps/octave.png" "${tmp_iconset}/icon_128x128.png"
  cp "${hicolor_dir}/256x256/apps/octave.png" "${tmp_iconset}/icon_128x128@2x.png"
  cp "${hicolor_dir}/256x256/apps/octave.png" "${tmp_iconset}/icon_256x256.png"
  cp "${hicolor_dir}/512x512/apps/octave.png" "${tmp_iconset}/icon_256x256@2x.png"
  cp "${hicolor_dir}/512x512/apps/octave.png" "${tmp_iconset}/icon_512x512.png"
  if [[ -e "${hicolor_dir}/1024x1024/apps/octave.png" ]]; then
    cp "${hicolor_dir}/1024x1024/apps/octave.png" "${tmp_iconset}/icon_512x512@2x.png"
  fi
  iconutil -c icns -o "${app_build}/Contents/Resources/applet.icns" "${tmp_iconset}"

  # Create or update entries in the application's plist
  plistbuddy=/usr/libexec/PlistBuddy
  info_plist="${app_build}/Contents/Info.plist"
  chmod a+w "${app_build}/Contents/Info.plist"
  $plistbuddy -c "Add :NSUIElement integer 1" "$info_plist"
  $plistbuddy -c "Add :CFBundleIdentifier string org.octave-app.Octave" "$info_plist"
  $plistbuddy -c "Add :CFBundleShortVersionString string $oct_ver" "$info_plist"
  $plistbuddy -c "Add :CFBundleVersion string \"$oct_ver_string\"" "$info_plist"
  $plistbuddy -c "Add :NSHumanReadableCopyright string \"$oct_copyright\"" "$info_plist"
  $plistbuddy -c "Add :CFBundleDocumentTypes array" "$info_plist"
  $plistbuddy -c "Add :CFBundleDocumentTypes:0 dict" "$info_plist"
  $plistbuddy -c "Add :CFBundleDocumentTypes:0:CFBundleTypeExtensions array" "$info_plist"
  $plistbuddy -c "Add :CFBundleDocumentTypes:0:CFBundleTypeExtensions: string \"m\"" "$info_plist"
  $plistbuddy -c "Add :CFBundleDocumentTypes:0:CFBundleTypeOSTypes array" "$info_plist"
  $plistbuddy -c "Add :CFBundleDocumentTypes:0:CFBundleTypeOSTypes: string \"Mfile\"" "$info_plist"
  $plistbuddy -c "Add :CFBundleDocumentTypes:0:CFBundleTypeRole string \"Editor\"" "$info_plist"
  $plistbuddy -c "Set :LSMinimumSystemVersionByArchitecture:x86_64 \"$this_macos_ver_majmin\"" "$info_plist"
  plutil -convert xml1 "${app_build}/Contents/Info.plist"
  chmod a=r "${app_build}/Contents/Info.plist"

  # Add icon to octave-gui (DISABLED)
  # This is broken as of macOS 12, and maybe earlier. It fails with a "ModuleNotFoundError: No module named 'Cocoa'" error.
  # Looks like the Cocoa module doesn't exist in the newer Pythons shipped with macOS. It may have been a Python 2 thing;
  # macOS has switched to Python 3 since the last time this worked.
#   if [[ "$build_gui" == "y" ]]; then
#     local python_script_tmp=$(mktemp /tmp/octave-XXXX);
#     cat <<EOSCRIPT > "$python_script_tmp"
# #!/usr/bin/env python
# # This is a Python 2.x script, and requires the macOS-specific Cocoa module
# import sys
# import Cocoa
#
# icons_file = sys.argv[1].decode("utf-8")
# oct_gui_file = sys.argv[2].decode("utf-8")
# wksp = Cocoa.NSWorkspace.sharedWorkspace()
# icons_data = Cocoa.NSImage.alloc().initWithContentsOfFile_(icons_file)
# ok = wksp.setIcon_forFile_options_(icons_data, oct_gui_file, 0)
# if not ok:
#   sys.exit("Unable to set file icons for file " + oct_gui_file + " from icons file " + icons_file)
#
# EOSCRIPT
#     # The glob here should produce exactly one file; it's just done for convenience in building the file path
#     # TODO: Replace the glob with an exact path.
#     /usr/bin/python3 "$python_script_tmp" "${app_build}/Contents/Resources/applet.icns" "${app_build_usr}/Cellar/${octave_formula}/*/libexec/octave/*/exec/*/octave-gui"
#   fi

  # List all included formulae in the VERSIONS file
  versions_file="${app_build}/Contents/Resources/VERSIONS"
  rm -f "${versions_file}"
  touch "${versions_file}"
  octave_app_str="Octave.app"
  if [[ -n "$variant" ]]; then
    octave_app_str="${octave_app_str} (variant ${variant})"
  fi
  octave_app_str="${octave_app_str}, version $oct_ver"
  if [[ -n "${build_suffix}" ]]; then
    octave_app_str="${octave_app_str}, build ${build_suffix}"
  fi
  echo "Octave.app version: ${octave_app_str}"
  echo "This is ${octave_app_str}" >> "${versions_file}"
  echo "" >> "$versions_file"
  "$brew" octave-app-list-formulae >> "${versions_file}"

  app_build_brew="${app_build_usr}/bin/brew"

  # Remove Homebrew itself
  # So Octave.app users don't use it and modify their app installation; it's not about saving space
  rm -rf "$app_build_usr/Homebrew" \
      "$app_build_usr/etc/bash_completion.d/brew" \
      "$app_build_usr/share/man/man1/README.md" \
      "$app_build_usr/share/man/man1/brew-cask.1" \
      "$app_build_usr/share/man/man1/brew.1" \
      "$app_build_usr/share/doc/homebrew" \
      "$app_build_usr/share/zsh/site-functions/_brew_cask" \
      "$app_build_usr/share/zsh/site-functions/_brew" \
      "$app_build_usr/bin/brew"

  # Redirect the app prefix's var/ to system local /var
  # Disabled because it seems to break code signing
  #rm -rf "$app_build_usr/var"
  #ln -s "/usr/local/var" "$app_build_usr/var"

  # Clear resource fork and Finder information that codesign doesn't like
  # Suppress errors because xattr seems to raise "no such file" errors for files
  # that sure look like they're there.
  # Disabled for now, since we're not doing code signing anyway.
  # xattr -rc "$app_build" || true

  # Lock down files to prevent accidental modification by users
  # Lock down the app M-files and brewed packages
  chmod -R a-w "${app_build_usr}/Cellar"
  # But Qt needs to write to the .qhc files and local dirs when using the help
  # viewer (really, Qt?)
  find "${app_build_usr}/Cellar/${octave_formula}" -name '*.qhc' | xargs chmod u+w
  find "${app_build_usr}/Cellar/${octave_formula}" -type d | xargs chmod u+w

  # Remove the STAGING flag file so you can tell it's a real built app now
  rm -rf "${app_build}/STAGING"

  echo "Munging complete. Removed STAGING flag file."
}

function sign_app() {
  # Sign the app bundle using Apple code signing (BROKEN)
  #
  # This currently does not work. It'll run, but the resulting app is not recognized
  # by macOS as signed for me.

  # Signing apparently must happen in the installation location to make codesign happy
  # with its internal symlinks.
  if [[ -e "$install_dir" ]]; then
    die "file exists at ${install_dir}. Cannot stage app to sign."
  fi
  mv "$app_build" "$install_dir"
  # Let's try making all symlinks absolute to get validation to work
  file_list_file=$(mktemp /tmp/octave-XXXXX)
  find "$install_dir" -type l | sort > "$file_list_file"
  while read link; do
    link_dir=$(dirname "$link")
    link_target=$(readlink "$link")
    (
      cd "$link_dir"
      real_target=$(realpath "$link_target")
      rm "$link"
      ln -s "$real_target" "$link"
    )
  done <${file_list_file}
  # Do the actual signing
  codesign -s "$codesign_author_name" -v "$install_dir"
  mv "$install_dir" "$app_build"
}

function create_dmg() {
  # Create a nice DMG disc image with create-dmg (MIT License)
  echo "Building DMG"
  dmg_dir=build

  if [[ ! -d "$app_build" ]]; then
    die "No app build present at $app_build. Please run the build and munge steps first."
  fi

  # Delete any existing DMG
  if [[ -f "${dmg_dir}/${dmg_name}" ]]; then
    echo "Deleting existing ${dmg_dir}/${dmg_name}"
    rm -rf "${dmg_dir}/${dmg_name}"
  fi

  # Run create-dmg. This may issue warnings if run headless. However, the DMG
  # will still be created, only some beautification cannot be applied.
  # We manually set the image size because create-dmg's automatic sizing seems to
  # get it wrong, and we run out of space when adding files.
  octave_app_tap="${install_usr}/Homebrew/Library/Taps/octave-app/homebrew-octave-app"
  "${bundler_home}/create-dmg/create-dmg" \
      --volname "${volume_name}" \
      --volicon "${app_build}/Contents/Resources/applet.icns" \
      --window-size 550 500 \
      --icon-size 48 \
      --icon "${app_name}.app" 125 180 \
      --hide-extension "${app_name}.app" \
      --app-drop-link 415 180 \
      --eula "${octave_app_tap}/assets/COPYING/COPYING.rtf" \
      --add-file COPYING "${octave_app_tap}/assets/COPYING" 126 300 \
      --add-file VERSIONS "${app_build}/Contents/Resources/VERSIONS" 415 300 \
      --disk-image-size 6400 \
      --background "${bundler_home}/assets/background.tiff" \
      "${dmg_dir}/${dmg_name}" \
      "$app_build"

  echo "DMG ready: ${dmg_dir}/${dmg_name}"
}

function test_app() {
  echo "Running test suite on built app..."
  if [[ ! -d "$app_build" ]]; then
    die "No app build present at ${app_build}. Please run the build and munge steps first."
  fi
  if [[ -d "$install_dir" ]]; then
    echo >&2 "An Octave.app already exists at ${install_dir}"
    echo >&2 "Please move it out of the way and then try test again."
    exit 1
  fi

  mv "$app_build" "$install_dir"
  osascript "${install_dir}/Contents/Resources/Scripts/main.scpt" --run-test-suite
  mv "$install_dir" "$app_build"
}

# Main program

# Handle special "actions" first
if [[ -n "$action" ]]; then
  case "$action" in
    brew)
      stage_app_build
      "$brew" "$@"
      exit_status=$?
      unstage_app_build
      exit $exit_status
      ;;
    *)
      die "Invalid action: '$action'"
      ;;
  esac
fi

if [[ -z "$build_step" ]]; then
  # Run entire build process
  stage_app_build
  freshen_staged_homebrew
  build_octave
  munge_build
  if [[ "$do_sign" == "y" ]]; then
    unstage_app_build
    sign_app
    stage_app_build
  fi
  if [[ "$build_dmg" == "y" ]]; then
    create_dmg
  fi
  unstage_app_build
  echo "Build finished."
else
  # Run a single step
  case "$build_step" in
    stage)            stage_app_build ;;
    unstage)          unstage_app_build ;;
    freshen-homebrew) freshen_staged_homebrew ;;
    build)            build_octave ;;
    munge)            munge_build ;;
    sign)             sign_app ;;
    dmg)              create_dmg ;;
    test)             test_app ;;
    *)
      echo >&2 "Error: Invalid step name '${build_step}'"
      echo >&2 "Error: Valid steps are: stage unstage freshen-homebrew build munge sign dmg test"
      exit 1
      ;;
  esac
fi
